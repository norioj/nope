repeat 
	task.wait() 
until game:IsLoaded() 
	and game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("ScreenGui") 
	and game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui.LoadingMessage.Visible == false
    
local scriptType = "Paid"

ExploitSpecific = "üìú"
Danger = "‚ö†Ô∏è"
Star = "‚≠ê"

-- Variables
local VirtualInputManager = game:GetService('VirtualInputManager')
local PathfindingService = game:GetService('PathfindingService')
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService('UserInputService')
local TweenService = game:GetService('TweenService')
local UserService = game:GetService("UserService")
local HttpService = game:GetService('HttpService')
local VirtualUser = game:GetService('VirtualUser')
local RunService = game:GetService('RunService')
local Workspace = game:GetService('Workspace')
local Lighting = game:GetService('Lighting')
local CoreGui = game:GetService('CoreGui')
local Players = game:GetService('Players')

local Flowers = Workspace.Flowers

local Activatables = ReplicatedStorage.Activatables
local MemoryMatchManager = ReplicatedStorage.MemoryMatchManager
local MemoryMatchGui = ReplicatedStorage.Gui.MemoryMatch

-- Modules
local ActivatablesHives = require(ReplicatedStorage.Activatables.Hives)
local ActivatablesToys = require(ReplicatedStorage.Activatables.Toys)
local ActivatablesNPC = require(ReplicatedStorage.Activatables.NPCs)
local ActivatablesPlanters = require(ReplicatedStorage.Activatables.Planter)

local ScreenInfo = require(ReplicatedStorage.ScreenInfo)
local Events = require(ReplicatedStorage.Events)
local Quests = require(ReplicatedStorage.Quests)

local PlanterTypes = require(ReplicatedStorage.PlanterTypes)
local NectarTypes = require(ReplicatedStorage.NectarTypes)
local EggTypes = require(ReplicatedStorage.EggTypes)
local BeeTypes = require(ReplicatedStorage.BeeTypes)

local LocalPlanters = require(ReplicatedStorage.LocalPlanters)
local Accessories = require(ReplicatedStorage.Accessories)
local Collectors = require(ReplicatedStorage.Collectors)

local checkTool = require(ReplicatedStorage.ItemPackages.Collector).PlayerHas
local checkAccessory = require(ReplicatedStorage.ItemPackages.Accessory).PlayerHas
local BuffTileModule = require(ReplicatedStorage.Gui.TileDisplay.BuffTile)
local MemoryMatchModule = require(ReplicatedStorage.Gui.MemoryMatch)
local ClientStatCache = require(ReplicatedStorage.ClientStatCache)
local MonsterTypes = require(game.ReplicatedStorage.MonsterTypes)
local MinigameGui = require(ReplicatedStorage.Gui.MinigameGui)
local timeToString = require(ReplicatedStorage.TimeString)
local AlertBoxes = require(ReplicatedStorage.AlertBoxes)
local StatTools = require(ReplicatedStorage.StatTools)
local StatReqs = require(ReplicatedStorage.StatReqs)
local ServerTime = require(ReplicatedStorage.OsTime)

local PlayerActivesCommand = ReplicatedStorage.Events.PlayerActivesCommand
local RetrievePlayerStats = ReplicatedStorage.Events.RetrievePlayerStats

local ScreenGui = ScreenInfo:GetScreenGui()

-- getgenv().api = loadstring(game:HttpGet("https://raw.githubusercontent.com/Narnia1337/hi/main/api.lua"))()
getgenv().api = loadstring(game:HttpGet("https://raw.githubusercontent.com/norioj/1350/main/1350"))()
local bssapi = loadstring(game:HttpGet("https://raw.githubusercontent.com/Narnia1337/hi/main/bssapi.lua"))()
local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/norioj/1350/main/hihi"))()

player = Players.LocalPlayer

local planterCacheDirectory = "macrov2-tester/plantercache/"..player.Name

if not isfolder("macrov2-tester") then makefolder("macrov2-tester") end
if not isfolder("macrov2-tester/plantercache") then makefolder("macrov2-tester/plantercache") end
if not isfolder(planterCacheDirectory) then makefolder("macrov2-tester/plantercache/"..player.Name) end

if not LPH_OBFUSCATED then
    getgenv().LPH_NO_VIRTUALIZE = function(...) warn("LPH_NO_VIRTUALIZE called") return(...) end
end

-- Destroy other macro v2 guis
for i, v in pairs(CoreGui:GetDescendants()) do
    if v:IsA("TextLabel") then
		if v.Text:find("Macro V2") then
			v.Parent.Parent:Destroy()
        end
    end
end

local currentMacroV2LoadedAt = tick()
getgenv().macroV2LoadedAt = currentMacroV2LoadedAt

local spawnedFuncs = {}
loopFunction = {}

plrHive = nil
httpreq = (syn and syn.request) or http_request or (http and http.request) or request
setIdentity = (syn and syn.set_thread_identity) or setthreadcontodo or setidentity

function loopFunction.spawn(func, noVirtualize, interval, name)
    if noVirtualize ~= true then noVirtualize = false end
    if not interval and not tonumber(interval) then interval = 1 end
    local shouldStop = false
    if noVirtualize then
        task.spawn(LPH_NO_VIRTUALIZE(function()
            while wait(interval) and not shouldStop do
                func()
                local succ, err = pcall(func)
                if not succ then warn((name and name..": "..err or err)) end
                if getgenv().macroV2LoadedAt ~= currentMacroV2LoadedAt then break end
            end
            print("stopped",name)
        end))
    else
        task.spawn(function()
            while wait(interval) and not shouldStop do
                local succ, err = pcall(func)
                if not succ then warn(name and name..": "..err or err) end
                if getgenv().macroV2LoadedAt ~= currentMacroV2LoadedAt then break end
            end
        end)
    end
    local newIndex = #spawnedFuncs + 1
    spawnedFuncs[newIndex] = function() shouldStop = true end
    return newIndex
end

function loopFunction.stop(id)
    if spawnedFuncs[id] then
        spawnedFuncs[id]()
        spawnedFuncs[id] = nil
    end
end

function loopFunction.stopAll()
    print("Cancelling all loop functions")
    for id, funcTask in pairs(spawnedFuncs) do
        -- funcTask:cancel()
        loopFunction.stop(id)
    end
    table.clear(spawnedFuncs)
end

getgenv().macrov2 = {
    toggles = {
        autodispensers = false,
        autoboosters = false,
        automemorymatch = false,

        -- Autofarm settings
        autofarm = false,
        autodig = false,
        converthiveballoon = false,
        convertHoney = true,
        farmBubbles = false,

        autoPlanters = false,

        -- Local Player Settings
        speedhack = false,

        --auto Toys
        autoMotherHouse = false,
        autoWealthClock = false,
        autoHoneystorm = false,
        autoFreeAntPass = false,
        autoFreeRoboPass = false,

        --auto Beesmas Toys
        autoSamovar = false,
        autoStockings = false,
        autoOnettArt = false,
        autoCandles = false,
        autoFeast = false,
        autoSnowMachine = false,
        autoHoneyWreath = false,

        -- Smart Farm Settings
        smartBlueAutofarm = false,
    },
    vars = {
        field = "Dandelion Field",

        -- Local Player Settings
        walkspeed = 60,
        equipAccessoryMethod = "Tween"
    },
    autoFarmSettings = {
        farmShower = false,
        smartBubbleBloat = false,
        smartPreciseCrosshair = false,
        smartPreciseMethod = "Fast Tween",
        farmUnderBalloons = false,
         farmPrecise = false,
         smartPrecise = false,
         farmFuzzy = false,
         smartFlame = false,
        smartBubbles = false,
        ignoreHoneyTokens = false,
        farmSprouts = false
    },
    convertSettings = {
        secondsBeforeConvert = 0,
        convertat = 100,
        convertballoonat = 0,
    },
    autodispensersettings = {
        treatDispenser = false,
        royalJellyDispenser = false,
        blueberryDispenser = false,
        strawberryDispenser = false,
        coconutDispenser = false,
        glueDispenser = false,
        freerobopass = false,
        freeantpass = false
    },
    autoboostersettings = {
        whiteBooster = false,
        redBooster = false,
        blueBooster = false
    },
    autoQuestSettings = {
        doQuests = false,
        doRepeatables = true,
        acceptAllQuests = false,

        BlackBearQuests = false,
        BrownBearQuests = false,
        PandaBearQuests = false,
        ScienceBearQuests = false,
        PolarBearQuests = false,
        SpiritsBearQuests = false,
        BuckoBeeQuests = false,
        RileyBeeQuests = false,
        HoneyBeeQuests = false,
        OnettQuests = false,

        -- Priorities
        enablePriorities = false,
        prioritizeMobKill = true,

        BlackBearPriority = 1,
        BrownBearPriority = 1,
        PandaBearPriority = 1,
        ScienceBearPriority = 1,
        PolarBearPriority = 1,
        SpiritBearPriority = 1,
        BuckoBeePriority = 1,
        RileyBeePriority = 1,
        HoneyBeePriority = 1,
        OnettPriority = 1,
        BeeBearPriority = 1,

        -- Beesmas only
        BeeBearQuests = false,

        farmPollen = false,
        farmGoo = false,
        killMobs = false,
        feedBees = false,
        useToys = false,
        useMemoryMatch = false,
        doQuestQuests = false,


        tpToNPC = false,
        doAnts = false,
        sendWebhook = true,

        bestBlueField = "Pine Tree Forest",
        bestRedField = "Rose Field",
        bestWhiteField = "Pumpkin Patch"

    },
    webhookSettings = {
        useWebhook = false,
        onlyTruncated = false,
        showTotalHoney = false,
        showHoneyPerHour = false,
        showDailyHoney = false,
        showPlanters = false,
        showNectars = false,
        showItems = false,

        discordId = LRM_LinkedDiscordID or "0",
        webhookUrl = "",
        webhookColor = "0xfcdf03",
        pingUser = false,
        messageFrequency = 30,

        itemsList = {},
    },
    autoPlantersSettings = {
        doPlanters = false,
        planterHarvestAt = 20,
        doCustomPlanters = false,
        blacklistedNectars = {},
        blacklistedPlanters = {}
    },
    autoPuffshroomSettings = {
        farmPuffshrooms = false,
        farmRemaining = true,
        rarityPriority = "Mythic > Common",
        levelPriority = "High > Low",
        minimumLevel = 1,
        maximumLevel = 16
    },
    combatSettings = {
        trainCrab = false,
        trainKingBeetle = false,
        trainTunnelBear = false,
        killVicious = false,
        viciousMinLevel = 1,
        viciousMaxLevel = 12,
    },
    customPlanterSettings = {
        customPlanters1 = {
            {planter = "", field = "", harvestAmount = 75},
            {planter = "", field = "", harvestAmount = 75},
            {planter = "", field = "", harvestAmount = 75},
            {planter = "", field = "", harvestAmount = 75},
            {planter = "", field = "", harvestAmount = 75}
        },
        customPlanters2 = {
            {planter = "", field = "", harvestAmount = 75},
            {planter = "", field = "", harvestAmount = 75},
            {planter = "", field = "", harvestAmount = 75},
            {planter = "", field = "", harvestAmount = 75},
            {planter = "", field = "", harvestAmount = 75}
        },
        customPlanters3 = {
            {planter = "", field = "", harvestAmount = 75},
            {planter = "", field = "", harvestAmount = 75},
            {planter = "", field = "", harvestAmount = 75},
            {planter = "", field = "", harvestAmount = 75},
            {planter = "", field = "", harvestAmount = 75}
        },
    },
    alertSettings = {
        viciousAlert = true
    },
    raresList = {}
}

getgenv().temptable = {
    version = "0.0.4b",
    convertingHoney = false,
    stopAll = false,
    activeMemoryMatch = nil,
    
    honeyAtStart = ClientStatCache.Get(nil,{"Totals", "Honey"}),
    lastWebhookSent = 0,

    tokenpath = Workspace.Collectibles,
    fieldDecosFolder = Workspace:FindFirstChild("FieldDecos") or ReplicatedStorage:FindFirstChild("FieldDecos"),
    lastWalkToNearest = 0,

    fieldSelected,
    fieldPosition,
    floversRow = {},

    customWalkSpeed = {enabled = false, speed = 50},

    plantingPlanter = false,

    detected = {
        vicious = false,
        windy = false
    },

    doingShower = false,
    doingMonster = false,
    doingTokens = false,

    lastClientStatCacheUpdate = 0,
    lastBalloonPollen = 0,

    showerStars = {},

    stopAutofarm = false,

    autoRJSettings = {
        requireGifted = false,
        requireAnyGifted = false,
        xCoord = 3,
        yCoord = 1,
        runningAutoRJ = false,
        selectedBees = {},
        selectedRarities = {}
    },
    showersTable = {},
    lastShowerRegistered = 0,

    sproutsTable = {},
    susTokenPositions = {},

    leafTable = {},
    sparklesTable = {},
    balloonsTable = {},

    codesTable = {
        "Wax",
        "Roof",
        "Nectar",
        "Crawlers",
        "Connoisseur",
        "Cog",
        "Buzz",
        "Bopmaster",
        "38217",
        "GumdropsForScience",
        "ClubConverters",
        "BeesBuzz123",
        "PlushFriday",
    }, codesActivated = false,

    stopEverything = false,

    puffsDetected = false,
    popStarActive = false,

    lastConvertAtHive = 0,
    lastFullBag = 0,

    tokensTable = {},
    lastTweenToRare = 0,

    selectedPriorityNpc = "Black Bear",
    npcPrioLabel = nil,
    npcPrioSlider = nil
}

-- Important Parts 
local cocoPad = Instance.new("Part")
cocoPad.Position = Workspace.Territories.CoconutTerritory.Position + Vector3.new(0,15,0)
cocoPad.Size = Workspace.Territories.CoconutTerritory.Size * Vector3.new(1,0,1) + Vector3.new(0,1,0)
cocoPad.Anchored = true
cocoPad.CanCollide = false
cocoPad.Transparency = 1
cocoPad.Parent = Workspace

local tunnelPart = Instance.new("Part")
tunnelPart.Anchored = true
tunnelPart.CanCollide = true
tunnelPart.Position = Vector3.new(410, 29, -48)
tunnelPart.Size = Vector3.new(10,1,10)
tunnelPart.Transparency = 1
tunnelPart.Parent = Workspace
Workspace.Decorations.TrapTunnel["Tunnel Ceiling"].CanCollide = false


function removeFromTable(Table, element)
    return table.remove(Table, table.find(Table, element))
end

function tweenNoclip()
    api.humanoidrootpart().Velocity = Vector3.new(0, 0, 0)
end

function calculateTweenSpeed(magnitude, speed)
    return magnitude / (speed or 40)
end

function bssAlert(style, text)
    secureCall(AlertBoxes.Push, player.PlayerScripts.AlertBoxes, nil, text, nil, style)
end

getgenv().tween = function(speed, objectPosition, secondsOnly)
    local character = player.Character
    local humanoid = character:FindFirstChild("Humanoid")
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if typeof(objectPosition) ~= "Vector3" then return warn("objectPosition is "..type(objectPosition).." Vector3 expected.") end
    if not humanoid or not humanoid.Parent then return end

    if humanoid.Health <= 0 then
        print("Called tween while player dead, waiting until respawn")
        player.CharacterAdded:Wait()
        wait(5)
        character = player.Character
        humanoid = character:FindFirstChild("Humanoid")
        humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        print("Respawned, continuing tween")
    end

    local tempMagnitude = (humanoidRootPart.Position - objectPosition).magnitude

    local newSpeed = calculateTweenSpeed(tempMagnitude, speed)
    if secondsOnly then newSpeed = speed end

    local tweenInfo = TweenInfo.new(newSpeed, Enum.EasingStyle.Linear)
    local tweenProperties = {CFrame = CFrame.new(objectPosition)}
    local tweenAnimation = TweenService:Create(humanoidRootPart, tweenInfo, tweenProperties)

    local antiFall
    local NoClipE

    if not humanoidRootPart:FindFirstChild("BodyVelocity-Tween") then
        AntiFall = Instance.new("BodyVelocity", humanoidRootPart)
        AntiFall.Velocity = Vector3.new(0, 0, 0)
        AntiFall.Name = "BodyVelocity-Tween"
        NoClipE = RunService.Stepped:Connect(tweenNoclip)
    end

    tweenAnimation:Play()
    local tweenCompleted = false
    local tweenStarted = tick()
    local tweenCompletedSignal = tweenAnimation.Completed:Connect(function() 
        tweenCompleted = true
    end)

    while not tweenCompleted and task.wait() do
        if humanoid.Health <= 0 or tick() - tweenStarted > 20 then
            print(humanoid.Health <= 0 and "Player dead while tween animation is running. Waiting for respawn" or tick() - tweenStarted > 20 and "Tween timeout, retying.")
            pcall(function()
                NoClipE:Disconnect()
                AntiFall:Destroy()
            end)
            tweenAnimation:Cancel()
            tweenCompletedSignal:Disconnect()
            if humanoid.Health <= 0 then
                if player.CharacterAdded:Wait(15) or humanoidRootPart.Parent and character.Parent and humanoid.Parent then
                    wait(5)
                else
                    print("Tween failed.")
                    return
                end
            end
            print("Continuing tween animation")
            return tween(speed, objectPosition)
        end
    end
    pcall(function()
        NoClipE:Disconnect()
        AntiFall:Destroy()
        end)
    -- print("Tween completed")
    return true
end
---close--
local InterfaceVisible = true
for i, player in pairs(game.Players:GetChildren()) do
 player.Chatted:Connect(function(mess) 
 if mess == "." then
  game.CoreGui["redui"]["ScreenGui"].Visible = not game.CoreGui["redui"]["ScreenGui"].Visible
 end
 end)
 end
getgenv().moveTo = function(pos)
    if not tween(50, pos) then error("Tween failed - main") end
end

function jsonEncode(tbl)
    local jsonString
    pcall(function() jsonString = HttpService:JSONEncode(tbl) end)
    return jsonString
end

function jsonDecode(json)
    local luaTable
    local a,s = pcall(function() luaTable = HttpService:JSONDecode(json) end)
    return luaTable
end

if macrov2.webhookSettings.discordId ~= "0" then
    api.notify("Macro V2", "Loaded discord id\n"..macrov2.webhookSettings.discordId, 3)
end

if _G.debugging then
    warn("Claim hive.")
end

function walkTo(pos, timeout)
    local startedWalking = tick()
    local walkFinished = false
    player.DevComputerMovementMode = Enum.DevComputerMovementMode.Scriptable
    api.humanoid():MoveTo(pos)
    local walkFinishedSignal = api.humanoid().MoveToFinished:Connect(function() walkFinished = true end)

    repeat 
        wait()
    until walkFinished or (tick() - startedWalking) > timeout

    pcall(function() walkFinishedSignal:Disconnect() end)
    api.humanoid():MoveTo(api.humanoidrootpart().Position)
    player.DevComputerMovementMode = Enum.DevComputerMovementMode.UserChoice
    return walkFinished
end

while not player:FindFirstChild("Honeycomb") do 
    wait(1)
    for i = 8,3,-1 do
        local hive = Workspace.Honeycombs:FindFirstChild("Hive"..i)
        if hive and not hive.Owner.Value then
            repeat
                if api.magnitude(hive.SpawnPos.Value.p, api.humanoidrootpart().Position) < 10 then
                    secureCall(ActivatablesHives.ButtonEffect, Activatables, player, hive.Platform.Value)
                     setIdentity(2)
                     ActivatablesHives.ButtonEffect(player, hive.Platform.Value)
                     setIdentity(7)
                else
                    moveTo(hive.SpawnPos.Value.p + Vector3.new(0,3,0))
                    wait(2)
                end
                wait()
            until hive.Owner.Value or player:FindFirstChild("Honeycomb")
            if player:FindFirstChild("Honeycomb") then break end
        end
    end
end

plrHive = player:FindFirstChild("Honeycomb").Value

if _G.debugging then
    warn("Claim hive done. Waiting 1 second")
    wait(1)
end

function findField(position)
    local ray = Ray.new(position+Vector3.new(0, -35, 0), Vector3.new(0,100, 0))
    local hit, hitPos = workspace:FindPartOnRayWithWhitelist(ray, {game.Workspace.FlowerZones})
    if hit and hit.Parent.Name == "FlowerZones" then
        return hit
    else
        return nil
    end
end

function getNumbers(str)
    local nums = {}
    for num in str:gmatch("%d+") do
        table.insert(nums, tonumber(num))
    end
    return nums
end

function truncate(num)
	num = tonumber(math.round(num))
	if num <= 0 then
		return 0
	end
	local savenum = ""
	local i = 0
	local suff = ""
	local suffixes = {"k","M","B","T","qd","Qn","sx","Sp","O","N"}
	local length = math.floor(math.log10(num)+1)
	while num > 999 do
		i = i + 1
		suff = suffixes[i] or "???"
		num = num/1000
		savenum = (math.floor(num*100)/100)..suff
	end
	if i == 0 then
		return num
	end
	return savenum
end

function truncatetime(sec)
	local second = tostring(sec%60)
	local minute = tostring(math.floor(sec / 60 - math.floor(sec / 3600) * 60))
	local hour = tostring(math.floor(sec / 3600))

	return (#hour == 1 and "0"..hour or hour)..":"..(#minute == 1 and "0"..minute or minute)..":"..(#second == 1 and "0"..second or second)
end

function addcommas(num)
	local str = tostring(num):reverse():gsub("(%d%d%d)", "%1,"):reverse()
	if str:sub(1,1) == "," then
		str = str:sub(2)
	end
	return str
end

function getTokenId(token)
    local id = "0"
    if token and token.Parent and token:FindFirstChildOfClass("Decal") then
        local texture = token:FindFirstChildOfClass("Decal").Texture
        local tempId = tonumber(tostring(texture):match("%d+"))
        if tempId then id = tempId end
    end
    return id
end

local shopLocations = {
    ["Diamond Mask"] = Vector3.new(-335, 132, -391),
    ["Demon Mask"] = Vector3.new(297, 27, 274)
}

function remoteEquipAccessory(accessory)
    Events.ClientCall("ItemPackageEvent", "Equip", {
        Mute = false,
        Type = accessory,
        Category = "Accessory"
    })
end

getgenv().requestAccessoryEquip = function(accessory, shop)
    local shopPosition = shopLocations[accessory] or shopLocations[shop]
    if not shopPosition then
        return false, "Invalid input!"
    end

    local accessoryType = accessoriesTable[accessory]
    if not accessoryType then
        return false, "Accessory not found!"
    end

    -- warn(accessoryType)

    if not checkAccessory({Type = accessory}, getClientStatCache()) then 
        return false, "Player does not have "..accessory
    end

    local currentAccessory = updateClientStatCache("EquippedAccessories", accessoryType)
    -- warn("Current Mask:",currentAccessory)
    -- warn("Requested Mask:",accessory)

    if currentAccessory == accessory then
        return false, "Already equipped " .. accessory
    end

    if macrov2.vars.equipAccessoryMethod == "Tween" then
        tween(70, shopPosition)
    elseif macrov2.vars.equipAccessoryMethod == "Teleport" then
        api.humanoidrootpart().CFrame = CFrame.new(shopPosition)
    end

    wait(0.1)
    if (api.magnitude(shopPosition) < 25) or macrov2.vars.equipAccessoryMethod == "Remote" then
        remoteEquipAccessory(accessory)
        return true
    else
        return false
    end
end

getgenv().getRandomRareToken = function()
    for i=#temptable.tokensTable, 1, -1 do
        local token = temptable.tokensTable[i]
        if not token or not token.Parent then continue end

        local tokenId = tostring(getTokenId(token))
        print(tokenId)
        if table.find(macrov2.raresList, tokenId) then
            return token
        end
    end
    for _,token in ipairs(temptable.tokensTable) do
         local tokenId = tostring(getTokenId(token))
         print(tokenId)
         if table.find(macrov2.raresList, tokenId) then
             return token
         end
    end
end

function getMinePlanters()
	local minePlantersTable = {}
    pcall(function()
        local plantedPlanters = debug.getupvalues(LocalPlanters.LoadPlanter)[4]
        for i, v in pairs(plantedPlanters) do
            if v.IsMine and v.PotModel and v.Active and not v.Collected then
                table.insert(minePlantersTable,v)
            end
        end
    end)
	return minePlantersTable
end

function updateClientStatCache(...)
    return ClientStatCache.Update(nil,{...})
end

function getClientStatCache(...)
    return ClientStatCache.Get(nil,{...})
end

function getDailyHoney()
    return ClientStatCache.GetDailyTotal(nil, "Honey") - (ClientStatCache.GetDailyTotal(nil, "ChallengeHoney") - (ClientStatCache.GetDailyTotal(nil, {"EggsReceived","SysHoney"})))
end

function getWarningDisks()
    local warningDisks = {}
    for i,v in pairs(game.Workspace.Particles:GetChildren()) do
          if v.Name == "WarningDisk" or v.Name == "Thorn" then 
              table.insert(warningDisks,v) 
          end
    end
    return warningDisks
  end

if _G.debugging then
    warn("Tables init.")
end

--Tables

local npcIconsEndpoint = "https://static.wikia.nocookie.net/bee-swarm-simulator/images/"
local npcsIcons = {
	["Polar Bear"]   = npcIconsEndpoint.."d/d4/Polarcloseup.png",
	["Bucko Bee"]    = npcIconsEndpoint.."3/3d/GiftedBuckoBeeNPCTransparent.png",
	["Black Bear"]   = npcIconsEndpoint.."c/c2/Blackcloseup.png",
	["Mother Bear"]  = npcIconsEndpoint.."1/15/Mothercloseup.png",
	["Brown Bear"]   = npcIconsEndpoint.."3/33/Browncloseup.png",
	["Panda Bear"]   = npcIconsEndpoint.."a/a0/Pandacloseup.png",
	["Science Bear"] = npcIconsEndpoint.."d/d5/Sciencecloseup.png",
	["Dapper Bear"]  = npcIconsEndpoint.."8/89/Dapperbearface.png",
	["Spirit Bear"]  = npcIconsEndpoint.."2/24/Spiritcloseup.png",
	["Riley Bee"]    = npcIconsEndpoint.."b/b0/GiftedRileyBeeNPCTransparent.png"
}

local nectarEmojis = {
	["Refreshing Nectar"]   = "<:Refreshing:1080956994070007818>",
	["Invigorating Nectar"] = "<:Invigorating:1080967902800392354>",
	["Comforting Nectar"]   = "<:Comforting:1080968750888652960>",
	["Motivating Nectar"]   = "<:Motivating:1080969173536096357>",
	["Satisfying Nectar"]   = "<:Satisfying:1080969460288073748>"
}

local plantersEmojis = {
	["Paper Planter"]         = "<:PaperPlanter:1084965375965405265>",
	["Ticket Planter"]        = "<:TicketPlanter:1084965386757345361>",
	["Festive Planter"]       = "<:FestivePlanter:1084965370579914854>",
	["Plastic Planter"]       = "<:PlasticPlanter:1084965381711597598>",
	["Candy Planter"]         = "<:CandyPlanter:1084965368147226716>",
	["Red Clay Planter"]      = "<:RedClayPlanter:1084965382911168583>",
	["Blue Clay Planter"]     = "<:BlueClayPlanter:1084950550946250833>",
	["Tacky Planter"]         = "<:TackyPlanter:1084965385222246470>",
	["Pesticide Planter"]     = "<:PesticidePlanter:1084965377727025372>",
	["Petal Planter"]         = "<:PetalPlanter:1084965380394598500>",
	["Heat-Treated Planter"]  = "<:HeatTreatedPlanter:1084950774989213797>",
	["Hydroponic Planter"]    = "<:HydroponicPlanter:1084965372442198177>",
	["The Planter Of Plenty"] = "<:ThePlanterOfPlenty:1084950301393567854>",
}

AllToysTable = {
    ["toysTable"] = {
        ['autoMotherHouse'] = "Gingerbread House",
        ['autoWealthClock'] = "Wealth Clock",
        ['autoHoneystorm'] = "Honeystorm",
        ['autoFreeAntPass'] = "Free Ant Pass Dispenser",
        ['autoFreeRoboPass'] = "Free Robo Pass Dispenser"
    },
    ["boostersTable"] = {
        ['whiteBooster'] = 'Field Booster',
        ['redBooster'] = 'Red Field Booster',
        ['blueBooster'] = 'Blue Field Booster'
    },
    ["dispensersTable"] = {
        ['treatDispenser'] = "Treat Dispenser",
        ['royalJellyDispenser'] = "Free Royal Jelly Dispenser",
        ['blueberryDispenser'] = "Blueberry Dispenser",
        ['strawberryDispenser'] = "Strawberry Dispenser",
        ['coconutDispenser'] = "Coconut Dispenser",
        ["glueDispenser"] = "Glue Dispenser"
    },
    ["beesmasToysTable"] = {
        ['autoSamovar'] = "Samovar",
        ['autoStockings'] = "Stockings",
        ['autoOnettArt'] = "Onett's Lid Art",
        ['autoCandles'] = "Honeyday Candles",
        ['autoFeast'] = "Beesmas Feast",
        ['autoSnowMachine'] = "Snow Machine",
        ['autoHoneyWreath'] = "Honey Wreath"
    },
    ["memoryMatchTable"] = {}
}

fieldsTable = {}
blueFields = {}
redFields = {}
whiteFields = {}

monstersTable = {}
plantersTable = {}
plantersDropdownTable = {}
nectarsTable = {}
accessoriesTable = {}

sproutRarities = {
    [Color3.fromRGB(103,162,201)] = "Moon",
    [Color3.fromRGB(180, 190, 186)] = "Common",
    
}

showerTable = {}
beesTable = {namesOnly = {}, fullData = {}, raritiesTable = {"Any Common", "Any Rare", "Any Epic", "Any Legendary", "Any Mythic"}}
npcsTable = {"Black Bear", "Brown Bear", "Panda Bear", "Science Bear", "Polar Bear", "Spirit Bear", "Bucko Bee", "Riley Bee", "Honey Bee", "Onett", "Bee Bear 5"}

nectarsDropdownTable = {
	"Comforting Nectar",
	"Satisfying Nectar",
	"Invigorating Nectar",
	"Refreshing Nectar",
	"Motivating Nectar"
}

if _G.debugging then
    warn("Tables init done. Waiting 1 second")
    wait(1)
end

if _G.debugging then
    warn("Tables init 2.")
end

--Tables init
for fieldIndex, field in pairs(Workspace.FlowerZones:GetChildren()) do
    table.insert(fieldsTable, field.Name)
    if not field:FindFirstChild("ColorGroup") then
        local colorGroup = Instance.new("StringValue")
        colorGroup.Name = "ColorGroup"
        colorGroup.Value = "White"
        colorGroup.Parent = field
    end
    if field.ColorGroup.Value == "Blue" then table.insert(blueFields, field.Name)
    elseif field.ColorGroup.Value == "Red" then table.insert(redFields, field.Name)
    elseif field.ColorGroup.Value == "White" then table.insert(whiteFields, field.Name)
    end
end

for i,v in pairs(Accessories.GetTypes()) do
    if v.Slot then
        accessoriesTable[i] = v.Slot
    end
end

for i,v in pairs(PlanterTypes.GetTypes()) do
    if v.Description == "Test planter." or i == "Plastic" or i == "Ticket" or i == "Festive" then continue end
    local planterData = {
        systemName = v.Name,
        displayName = v.DisplayName,
        nectarMultipliers = v.NectarMultipliers,
        pollenMultipliers = v.PollenMultipliers
    }
    plantersTable[v.Name] = planterData
    table.insert(plantersDropdownTable, v.DisplayName)
end

-- writefile("newPlanters.json", Encode(plantersTable))

for i,v in pairs(NectarTypes.GetTypes()) do
    nectarsTable[i] = v.Fields
end

for i,v in pairs(temptable.tokenpath:GetChildren()) do
    table.insert(temptable.susTokenPositions, v.Position)
end


for i,v in pairs(Workspace.MonsterSpawners:GetChildren()) do
    monstersTable[v.Name] = {RespawnCooldown = 0, MonsterType = nil}
    monstersTable[v.Name].MonsterType = v.MonsterType.Value
    monstersTable[v.Name].RespawnCooldown = MonsterTypes.Get(v.MonsterType.Value).Stats.RespawnCooldown
    monstersTable[v.Name].Spawner = v
    if v.Name == "WerewolfCave" then
        monstersTable[v.Name].Territory = v.Territory.Value.w
    elseif v.Name == "MushroomBush" then
        monstersTable[v.Name].Territory = v.Territory.Value.Part
    else
        monstersTable[v.Name].Territory = v.Territory.Value
    end
end

for i,v in pairs(Workspace.Toys:GetChildren()) do
    if v.Name:find("Memory Match") then table.insert(AllToysTable["memoryMatchTable"], v.Name) end
end

for i,v in pairs(require(game:GetService("ReplicatedStorage").BeeTypes).GetTypes()) do
    table.insert(beesTable.namesOnly, i.." Bee")
    beesTable.fullData[i] = {Rarity = v.Rarity}
end

if _G.debugging then
    warn("Tables init 2. Waiting 1 second")
    wait(1)
end

--Functions

function markAsCollected(object)
    local collectedCache = Instance.new("Folder")
    collectedCache.Name = "Collected"
    collectedCache.Parent = object
end

local cachedFieldFlowers = {}

function getAllFlowers(field)
    local fieldId = field.ID.Value
    local fieldFlowers
    if cachedFieldFlowers[field.Name] then
        -- print("cached")
        fieldFlowers = cachedFieldFlowers[field.Name]
    else
        print("firstInit")
        fieldFlowers = {}
        for flowerIndex, flower in pairs(Workspace.Flowers:GetChildren()) do
            local flowerInfo = getNumbers(flower.Name)
            if #flowerInfo == 3 and flowerInfo[1] == fieldId then
                table.insert(fieldFlowers, flower)
            end
        end
        if not (#fieldFlowers <= 1) then 
            cachedFieldFlowers[field.Name] = fieldFlowers 
        else
            return 
        end
    end
    return fieldFlowers
end

function getRandomFlower(field)
    local fieldId = field.ID.Value
    local fieldFlowers
    if cachedFieldFlowers[field.Name] then
        -- print("cached!")
        fieldFlowers = cachedFieldFlowers[field.Name]
    else
        print("firstInit")
        fieldFlowers = {}
        for flowerIndex, flower in pairs(Workspace.Flowers:GetChildren()) do
            local flowerInfo = getNumbers(flower.Name)
            if #flowerInfo == 3 and flowerInfo[1] == fieldId then
                table.insert(fieldFlowers, flower)
            end
        end
        if not (#fieldFlowers <= 1) then 
            cachedFieldFlowers[field.Name] = fieldFlowers 
        else
            return 
        end
    end
    return fieldFlowers[math.random(1,#fieldFlowers)]
end

local cachedFieldCenters = {farm = {}, sprinkler = {}}

function getNewFarmCenter(field, sprinkler)
    if not (field:FindFirstChild("ColorGroup") and field.ColorGroup.Value == "Blue") then return end
    if sprinkler and cachedFieldCenters["sprinkler"][field.Name] then 
        return cachedFieldCenters["sprinkler"][field.Name] 
    elseif not sprinkler and cachedFieldCenters["farm"][field.Name] then
        return cachedFieldCenters["farm"][field.Name] 
    end
    local flowers = getAllFlowers(field)
    local minX = math.huge
    local minY = math.huge
    local maxX = -math.huge
    local maxY = -math.huge
    
    for i, flower in ipairs(flowers) do
        local flowerSettings = getNumbers(flower.Name)
        minX = math.min(minX, flowerSettings[2])
        minY = math.min(minY, flowerSettings[3])
        maxX = math.max(maxX, flowerSettings[2])
        maxY = math.max(maxY, flowerSettings[3])
    end

    local flowerCenter 
    if maxX - minX >= maxY - minY then -- x is longer
        local centerFlowerX = sprinkler and maxX - 5 or maxX
        local centerFlowerY = sprinkler and maxY - 5 or maxY --math.floor((minY + maxY) / 2 + 0.5)
        for i,v in pairs(flowers) do
            if v.Name == "FP"..field.ID.Value.."-"..centerFlowerX.."-"..centerFlowerY then
                flowerCenter = v
                break
            end
        end
    else -- y is longer
        local centerFlowerX = sprinkler and maxX - 5 or maxX --math.floor((minX + maxX) / 2 + 0.5)
        local centerFlowerY = sprinkler and maxY - 5 or maxY
        for i,v in pairs(flowers) do
            if v.Name == "FP"..field.ID.Value.."-"..centerFlowerX.."-"..centerFlowerY then
                flowerCenter = v
                break
            end
        end
    end
    if flowerCenter then
        if sprinkler and not cachedFieldCenters["sprinkler"][field.Name] then 
            cachedFieldCenters["sprinkler"][field.Name] = flowerCenter
        elseif not sprinkler and not cachedFieldCenters["farm"][field.Name] then
            cachedFieldCenters["farm"][field.Name] = flowerCenter
        end
    end
    return flowerCenter
end

function jump()
    if not player.Character.Humanoid.Jump then
        player.Character.Humanoid.Jump = true
    end
end

function getPlanterData(planterName)
    local planterData
    if plantersTable[planterName] then 
        planterData = plantersTable[planterName] 
    else
        for i,v in pairs(plantersTable) do
            if v.displayName == planterName then
                planterData = v
                break
            end
        end
    end
    return planterData
end

function gethiveballoon()
    for _,balloon in pairs(Workspace.Balloons.HiveBalloons:GetChildren()) do
        if balloon:FindFirstChild("BalloonRoot") then
            if balloon.BalloonRoot.CFrame.p.X == player.SpawnPos.Value.p.X then
                return true
            end
        end
    end
    return false
end

function getBuffTime(buffName, convertToHMS)
    local buff = BuffTileModule.GetBuffTile(buffName)
    if not buff or not buff.TimerDur or not buff.TimerStart then 
        return 0 
    end

    local toReturn = buff.TimerDur - (math.floor(ServerTime()) - buff.TimerStart)
    if convertToHMS then 
        toReturn = timeToString(toReturn) 
    end
    
    return toReturn
end

function getBuffStack(buffName)
    local buff = BuffTileModule.GetBuffTile(buffName)

    return (buff and tostring(buff.Combo)) or 0
end

function getCurrentTime()
    local CurrentTime = Lighting.ClockTime
    return (CurrentTime > 10 and "Day") or "Night"
end

function disableall()
    temptable.disableAll = true
end

function enableall()
    temptable.disableAll = false
end

function dig()
    local tool = player.Character:FindFirstChildOfClass("Tool") or nil
    if not tool then return end
    getsenv(tool.ClientScriptMouse).collectStart(player:GetMouse())
end

function isFieldSame(pos1, pos2)
    return findField(pos1) == findField(pos2)
end

if _G.debugging then
    warn("Functions init.")
end

function canTaskBeSpawned(taskName)
    if taskName == "getToys" then
        if temptable.puffsDetected then return false end

        return true
    elseif taskName == "farmPlanters" then
        if temptable.puffsDetected then return false end

        return true
    elseif taskName == "killVicious" then

        return true
    elseif taskName == "trainBosses" then
        if temptable.puffsDetected then return false end

        return true
    end
end

function canCollectToken(token)
    return 
    token.Parent and 
    ((api.humanoidrootpart().Position * Vector3.new(0,1,0)) - (token.Position * Vector3.new(0,1,0))).magnitude < 6 and
    token.CFrame.YVector.Y == 1
end

function getNearestBubble(callback)
    local nearest = {bubble = nil, distance = math.huge}
    for _,bubble in pairs(Workspace.Particles:GetChildren()) do
        if bubble.Name ~= "Bubble" then continue end
        if callback and not callback(bubble) then continue end
        local distance = api.magnitude(bubble.Position)
        if distance < nearest.distance then
            nearest = {bubble = bubble, distance = distance}
        end
    end
    return nearest.bubble, nearest.distance
end

function getNearestToken(blacklistedTokens, callback)
    local nearest = {token = nil, distance = math.huge}
    for _, token in ipairs(temptable.tokenpath:GetChildren()) do
        if blacklistedTokens and table.find(blacklistedTokens, token) then warn("Token blacklisted") continue end
        if callback and not callback(token) then continue end
        if canCollectToken(token) then
            local distance = api.magnitude(token.Position)
            -- print(distance, nearest.distance)
            if distance < nearest.distance then
                nearest = {token = token, distance = distance}
            end
        end
    end
    return nearest.token, nearest.distance
end

function getNearestBalloon(callback) 
    local nearest = {token = nil, distance = math.huge}
    for _, balloon in pairs(temptable.balloonsTable) do
        if callback and not callback(balloon) then continue end
        if not balloon:FindFirstChild("BalloonBody") then continue end
        local distance = api.magnitude(balloon.BalloonBody.Position)
        -- print(distance, nearest.distance)
        if distance < nearest.distance then
            nearest = {balloon = balloon, distance = distance}
        end
    end
    return nearest.balloon, nearest.distance
end

function getNearestTask(callback)
    local nearest = {taskName = "", distance = math.huge, object = nil}
    local nearestToken, tokenDistance = getNearestToken(nil, callback)
    local nearestBubble, bubbleDistance = getNearestBubble(nil, callback)
    if tokenDistance < nearest.distance then 
        nearest = {taskName = "Token", distance = tokenDistance, object = nearestToken}
    end
    if bubbleDistance-1 < nearest.distance and macrov2.toggles.farmBubbles then
        nearest = {taskName = "Bubble", distance = bubbleDistance, object = nearestBubble}
    end
    return nearest.taskName, nearest.object
end

function getTokenLink()
    local nearestTokenLink = {token = nil, distance = math.huge}
    for _,token in ipairs(temptable.tokenpath:GetChildren()) do
        if getTokenId(token) == 1629547638 and token.CFrame.YVector.Y == 1 and not token:FindFirstChild("Collected") then
            local distance = (token.Position - player.Character.HumanoidRootPart.Position).magnitude
            if distance < nearestTokenLink.distance then
                nearestTokenLink = {token = token, distance = distance}
            end
        end
    end
    return nearestTokenLink.token
end

function collectToken(token)
    if not token.Parent or token:FindFirstChild("Collected") then return false end
    local startedCollecting = tick()
    local moveToCalled = -1
    local collected = false
    while true do
        --print("Collecting")
        if (api.humanoidrootpart().Position - token.Position).magnitude < 4 or
            token.CFrame.YVector.Y ~= 1 or
            not workspace:FindPartOnRay(Ray.new(api.humanoidrootpart().Position, token.Position - api.humanoidrootpart().Position)) or
            (token.Position - api.humanoidrootpart().Position).magnitude < 4 or
            (tick() - startedCollecting) >= 8
        then
            collected = true
            break
        end
        
        if tick() - moveToCalled > 0.5 then
            if (tick() - temptable.lastTweenToRare) < 5 then break end
            api.humanoid():MoveTo(token.Position)
            moveToCalled = tick()
        end

        RunService.Heartbeat:Wait()
    end
    api.humanoid():MoveTo(api.humanoidrootpart().Position)
    if collected then
        markAsCollected(token)
        return true
    else
        return false
    end
end

function farmToken(customCallback)
    local nearestTokenLink = getTokenLink()
    if nearestTokenLink then
        -- print("Token Link")
        collectToken(nearestTokenLink)
        return true
    else
        local tokenToCollect = getNearestToken(nil, function(token)
            if customCallback and not customCallback(token) then 
                return false
            end
            if token.CFrame.YVector.Y == 1 and not token:FindFirstChild("Collected") and not table.find(temptable.susTokenPositions, token.Position) then 
                return true 
            end 
        end)
        if not tokenToCollect then return end
        collectToken(tokenToCollect)
        return true
    end
end

function farmBubble(customCallback)
    local nearestBubble = getNearestBubble(function(bubble)    
        if customCallback and not customCallback(bubble) then 
            return false
        end    
        if not bubble:FindFirstChild("Collected") then return true end
    end)
    if not nearestBubble then return false end

    local startedCollecting = tick()
    local moveToCalled = -1

    while true do
        if api.magnitude(nearestBubble.Position) < 8.5 or
        not nearestBubble.Parent or
        (tick() - startedCollecting) >= 8 then
            break
        end
        
        if tick() - moveToCalled > 0.5 then
            api.humanoid():MoveTo(nearestBubble.Position)
            moveToCalled = tick()
        end

        RunService.Heartbeat:Wait()
    end

    markAsCollected(nearestBubble)
    return true
end

function gotoNearestBalloon(waitForMoveFinish)
    -- print("Called gotoNearestBalloon")
    local balloon = getNearestBalloon(function(balloon) 
        if balloon and balloon.Parent and balloon:FindFirstChild("BalloonBody") and isFieldSame((temptable.fieldSelected and temptable.fieldSelected.Position or api.humanoidrootpart().Position), balloon.BalloonBody.Position - Vector3.new(0,15,0)) then return true end
    end)
    if balloon and balloon:FindFirstChild("BalloonBody") and api.magnitude(balloon.BalloonBody.Position) > 10 then
        api.humanoid():MoveTo(balloon.BalloonBody.Position)
        if waitForMoveFinish then
            local startMove = tick()
            repeat wait() until api.magnitude(balloon.BalloonBody.Position) < 6 or (tick() - startMove) > 1
        else
            wait()
        end
    end
end

local puffsRarityList = {
    Common = 1,
    Rare = 2,
    Epic = 3,
    Legendary = 4,
    Mythic = 5
}

function checkPuffshrooms()
    local puffFound = false
    if #Workspace.Happenings.Puffshrooms:GetChildren() > 0 then
        puffFound = true
    else
        for i,v in pairs(Workspace.Particles:GetChildren()) do
            if v.Name == "SporeCloud" then
                puffFound = true
                break
            end
        end
    end
    temptable.puffsDetected = puffFound
    return puffFound
end

function checkPopStar()
    if not Workspace.Particles:FindFirstChild("PopStars") then return false end
    local popStarFound = false
    for i,v in pairs(Workspace.Particles.PopStars:GetChildren()) do
        if (player.Character.HumanoidRootPart.Position - v.Position).magnitude < 13
        and getBuffTime("Pop Star Aura") > 0 then
            popStarFound = true
            break 
        end
    end
    temptable.popStarActive = popStarFound
    return popStarFound
end

-- function checkLeafsAndSparkles()
--     local leafTable = {}
--     for _, flower in ipairs(Flowers:GetChildren()) do
--         if flower:FindFirstChild("LeafBurst") then
--             table.insert(leafTable, flower)
--         elseif flower:FindFirstChild("Sparkles")then
--             table.insert(sparklesTable, flower)
--         end
--     end
--     temptable.leafTable = leafTable
--     return leafTable
-- end

function getPuffsOnField(field)
    local puffsOnField = {}
    for i,v in pairs(Workspace.Happenings.Puffshrooms:GetChildren()) do
        if findField(v.PrimaryPart.Position) == field then
            table.insert(puffsOnField, v)
        end
    end
    return puffsOnField
end

function getBestPuffshroom()
    local puffs = Workspace.Happenings.Puffshrooms:GetChildren()
    if #puffs == 0 then return nil end
    local bestPuffs = {}

    local maxRarity = macrov2.autoPuffshroomSettings.rarityPriority == "Mythic > Common" and 0 or 6

    for i, puff in ipairs(puffs) do
        local puffName
        pcall(function()
            puffName = puff["Puffball Top"].Attachment.Gui.NameRow.TextLabel.Text
        end)
        if not puffName then warn("No puff name") return {} end
        local puffRarity = string.match(puffName, "(%a*)%s+Puffshroom") or "Common"
        local puffLevel = tonumber(string.match(puffName, "Lvl (%d+)"))
        if not tonumber(puffLevel)
          or not puffLevel 
          or tonumber(puffLevel) < macrov2.autoPuffshroomSettings.minimumLevel
          or tonumber(puffLevel) > macrov2.autoPuffshroomSettings.maximumLevel 
          or not puff:FindFirstChild("Puffball Stem")
          or not findField(puff["Puffball Stem"].Position)
        then continue end
        local rarityValue = puffsRarityList[puffRarity] or 1

        if (macrov2.autoPuffshroomSettings.rarityPriority == "Mythic > Common" and rarityValue > maxRarity) or
           (macrov2.autoPuffshroomSettings.rarityPriority == "Common > Mythic" and rarityValue < maxRarity) then
            maxRarity = rarityValue
            bestPuffs = { puff }
        elseif rarityValue == maxRarity then
            table.insert(bestPuffs, puff)
        end
    end

    table.sort(bestPuffs, function(a, b)
        local aName = a["Puffball Top"].Attachment.Gui.NameRow.TextLabel.Text
        local aRarity, aLevel = string.match(aName, "(%a*)%s+Puffshroom") or "Common", tonumber(string.match(aName, "Lvl (%d+)"))
        
        local bName = b["Puffball Top"].Attachment.Gui.NameRow.TextLabel.Text
        local bRarity, bLevel = string.match(bName, "(%a*)%s+Puffshroom") or "Common", tonumber(string.match(bName, "Lvl (%d+)"))
        -- local aRarity, aLevel = a.Name:match("(%a*)%s+Puffshroom%s+%(%a*%s*(%d+)%)")
        -- local bRarity, bLevel = b.Name:match("(%a*)%s+Puffshroom%s+%(%a*%s*(%d+)%)")
        aLevel, bLevel = tonumber(aLevel), tonumber(bLevel)
        local aRarityValue, bRarityValue = puffsRarityList[aRarity] or 1, puffsRarityList[bRarity] or 1
        if aRarityValue == bRarityValue then
            if macrov2.autoPuffshroomSettings.levelPriority == "High > Low" then
                return aLevel > bLevel
            else
                return aLevel < bLevel
            end
        else
            if macrov2.autoPuffshroomSettings.rarityPriority == "Mythic > Common" then
                return aRarityValue > bRarityValue
            else
                return aRarityValue < bRarityValue
            end
        end
    end)

    local bestPuff = bestPuffs[1]
    -- print(bestPuff["Puffball Top"].Attachment.Gui.NameRow.TextLabel.Text)
    if bestPuff then
        local puffName = bestPuff["Puffball Top"].Attachment.Gui.NameRow.TextLabel.Text
        local puffRarity = string.match(puffName, "(%a*)%s+Puffshroom") or "Common"
        local puffLevel = tonumber(string.match(puffName, "Lvl (%d+)"))
        return { Rarity = puffRarity, Level = tonumber(puffLevel), Model = bestPuff }
    end

    return nil
end

function farmPuffshroom(puffToFarm)
    local farmed = false
    local stem = puffToFarm.PrimaryPart
    if stem and puffToFarm.Parent == Workspace.Happenings.Puffshrooms then
        local stemPos = stem.Position
        if not isFieldSame(api.humanoidrootpart().Position, stemPos) then
            moveTo(stemPos)
        end
        placeSprinkler(stemPos, true, true)
        while wait() and puffToFarm.Parent == Workspace.Happenings.Puffshrooms and macrov2.autoPuffshroomSettings.farmPuffshrooms and macrov2.toggles.autofarm do
            if getBagPercentage() >= 99 then return false, "Bag is full" end
            if not isFieldSame(api.humanoidrootpart().Position, stemPos) then
                moveTo(stemPos)
            elseif api.magnitude(stemPos) >= 20 then
                wait()
                walkTo(stemPos, 0.5)
            elseif api.magnitude(stemPos) < 20 then
                collectNearestTokens(stemPos, 30)
                wait()
            else
                moveTo(stemPos)
            end
            farmed = true
        end
        if farmed and puffToFarm.Parent ~= Workspace.Happenings.Puffshrooms and macrov2.toggles.autofarm and macrov2.autoPuffshroomSettings.farmPuffshrooms then
            wait(0.5)
            for i=1,2 do
                collectNearestTokens()
                wait()
            end
            return true
        end
    end
    return false
end

-- function farmPuffshrooms()
--     local puffToFarm = getBestPuffshroom()
--     local farmed = 0

--     if not puffToFarm or not puffToFarm.Model then return false else puffToFarm = puffToFarm.Model end
--     local firstPuffOnField = findField(puffToFarm.PrimaryPart.Position)
--     if farmPuffshroom(puffToFarm) then 
--         if macrov2.autoPuffshroomSettings.farmRemaining then
--             local puffs = Workspace.Happenings.Puffshrooms:GetChildren()
--             for i,v in pairs(puffs) do
--                 if findField(v.PrimaryPart.Position) ~= firstPuffOnField then puffs[i] = nil end
--             end

--             table.sort(puffs)

--             if #puffs > 0 then
--                 while #puffs > 0 do

--                     if not puffs[1].Parent or not puffs[1].PrimaryPart then puffs[1] = nil continue end

--                     farmPuffshroom(puffs[1])
--                     farmed += 1
--                 end
--             end
--         end
--     end
--     if farmed == 0 then return false end
--     return true
-- end

function farmPuffshrooms()
    local firstPuff = getBestPuffshroom()
    if not firstPuff or not firstPuff.Model then return end
    local puffsOnField = {}

    local puffSelected = firstPuff.Model
    local fieldSelected = findField(firstPuff.Model.PrimaryPart.Position)

    while puffSelected and puffSelected.Parent do
        wait()
        local done, msg = farmPuffshroom(puffSelected)
        if msg == "Bag is full" then return false end
        wait()
        if macrov2.autoPuffshroomSettings.farmRemaining then
            puffsOnField = getPuffsOnField(fieldSelected)
            if #puffsOnField > 0 then
                for i,v in pairs(puffsOnField) do
                    if v.Parent then
                        puffSelected = v
                        break
                    end
                end
            end
            wait()
        end
    end
end

function avoidWarningDisks()
    local playerPos = api.humanoidrootpart().Position
    local warningDisks = getWarningDisks()

    local ray = Ray.new(playerPos + Vector3.new(0, 100, 0), Vector3.new(1, -735, 1))
    local touchedWarningDisk = Workspace:FindPartOnRayWithWhitelist(ray, warningDisks)

    if touchedWarningDisk then
        local diskRadius = touchedWarningDisk.Size.X / 2
        local dirToPlayer = (playerPos - touchedWarningDisk.Position).Unit
        
        -- Calculate the safe position to move to
        local diskCenter = touchedWarningDisk.Position
        local playerToCenter = (playerPos - diskCenter).Magnitude
        local playerToDisk = playerToCenter - diskRadius
        local safePos = diskCenter + dirToPlayer * (diskRadius + 4 + playerToDisk + 5)
        if (safePos - api.humanoidrootpart().Position).magnitude < 0.5 then safePos = api.humanoidrootpart().Position + Vector3.new(1,0,0) end
        api.humanoid():MoveTo(safePos + Vector3.new(1,0,1))
        wait()
        return true
    end
    wait()
    return false
end

getgenv().shouldIConvert = function(converting)
    local timeSinceLastFullBag = tick() - temptable.lastFullBag -- Calculate the time elapsed since the last conversion

    if timeSinceLastFullBag < macrov2.convertSettings.secondsBeforeConvert then -- Check if the user wants to wait before converting, and if enough time has elapsed
        return false
    elseif converting and getBagPercentage() > 0 or getBagPercentage() >= macrov2.convertSettings.convertat then -- Check if the bag is full or if the user wants to convert manually
        return true
    else
        if temptable.puffsDetected and macrov2.autoPuffshroomSettings.farmPuffshrooms then return false end

        if macrov2.toggles.converthiveballoon and gethiveballoon() then
            if macrov2.convertSettings.convertballoonat == 0 and converting then
                return true
            elseif macrov2.convertSettings.convertballoonat ~= 0 and (getBuffTime("Balloon Blessing")/60) <= macrov2.convertSettings.convertballoonat then
                return true
            else
                return false
            end
        else
            return false
        end
    end
end

getgenv().getBagPercentage = function()
    local pollencount = player.CoreStats:FindFirstChild("Pollen") and player.CoreStats.Pollen.Value or 0
    local maxpollen = player.CoreStats:FindFirstChild("Capacity") and player.CoreStats.Capacity.Value or 0
    -- print(pollencount, maxpollen)

    local percentage = (pollencount / maxpollen * 100) or 0

    if temptable.lastFullBag == 0 and percentage >= macrov2.convertSettings.convertat then
        temptable.lastFullBag = tick()
    elseif not (percentage >= macrov2.convertSettings.convertat) then
        temptable.lastFullBag = 0
    end

    return percentage
end

function convertHoney()
    -- print("Convert Honey Called")
    local hivePos = (player.SpawnPos.Value * CFrame.fromEulerAnglesXYZ(0, 110, 0) + Vector3.new(0, 0, 9)).p
    while shouldIConvert(true) and macrov2.toggles.convertHoney do
        temptable.convertingHoney = true
        if api.magnitude(player.SpawnPos.Value.p) > 10 then
            moveTo(hivePos)
        end
        setIdentity(2)
        local hiveInfo = ActivatablesHives.ButtonText(player)
        setIdentity(7)
        -- print(hiveInfo)
        if hiveInfo == "Make Honey" then
            print("Making honey")
            secureCall(ActivatablesHives.ButtonEffect, Activatables, player, plrHive.Platform.Value)
            setIdentity(2)
            ActivatablesHives.ButtonEffect(player, plrHive.Platform.Value)
            setIdentity(7)
            wait(3)
        elseif hiveInfo == "To Make Honey, Collect Pollen From Flower Fields." then
            print("Everything converted")
            break
        end
        wait(1)
    end
    wait(5)
    temptable.convertingHoney = false
    print("converted")
    temptable.lastConvertAtHive = tick()
end

function canToyBeUsed(toyName)
    local toy = Workspace.Toys[toyName]
    if toy then
        local _, buttonColor = secureCall(ActivatablesToys.ButtonText, Activatables, nil, toy)
        if not buttonColor then
            return true
        elseif buttonColor == "Red" then
            return false    
        end
    end
end

function useToy(toyName, collectTokens)
    if not canToyBeUsed(toyName) then return end
    local used = false
    local patformPosition = Workspace.Toys[toyName].Platform.Position + Vector3.new(0,3,0)
    wait()
    while 
     not temptable.convertingHoney
     and canToyBeUsed(toyName) 
    do
        if api.magnitude(patformPosition) > 20 then
            moveTo(patformPosition)
            wait(0.25)
        end
        if api.magnitude(patformPosition) < 20 then
            secureCall(ActivatablesToys.ButtonEffect, Activatables, player, workspace.Toys[toyName])
            -- setIdentity(2)
            -- ActivatablesToys.ButtonEffect(player, workspace.Toys[toyName])
            -- setIdentity(7)
        end
        wait(2)
    end
    if collectTokens then 
        wait(1.5)
        local tokensNear = {}
        for _, token in pairs(temptable.tokenpath:GetChildren()) do
            if api.magnitude(token.Position, patformPos) < 25
            and token.CFrame.YVector.Y == 1
            and getTokenId(token) ~= 65867881 then
                table.insert(tokensNear, token)
            end
        end
        while #tokensNear > 0 do
            for _, token in pairs(tokensNear) do
                if api.magnitude(patformPosition) > 25 then
                    moveTo(patformPosition)
                end
                if not token.Parent then table.remove(tokensNear, _) continue end
                collectToken(token)
            end
            wait()
        end 
    end
end

function useMemoryMatch(memoryMatch, isQuest)
    if canToyBeUsed(memoryMatch) and not temptable.convertingHoney then disableall() else return "first" end
    local patformPos = Workspace.Toys[memoryMatch].Platform.Position
    local used = false
    while canToyBeUsed(memoryMatch) 
          and (not isQuest and macrov2.toggles.automemorymatch or isQuest and macrov2.autoQuestSettings.useMemoryMatch)
          and not temptable.activeMemoryMatch
    do
        moveTo(patformPos + Vector3.new(0,3,0))
        wait(0.5)
        if (patformPos - api.humanoidrootpart().Position).Magnitude < 15 then
            secureCall(ActivatablesToys.ButtonEffect, Activatables, player, workspace.Toys[memoryMatch])
            used = true
            -- setIdentity(2)
            -- ActivatablesToys.ButtonEffect(player, workspace.Toys[memoryMatch])
            -- setIdentity(7)
            -- api:pressButton("E")
        end
        wait(1)
    end
    if not used then return end
    warn("MM step 1")
    repeat wait() until temptable.activeMemoryMatch
    warn("MM step 2")
    repeat wait() until not temptable.activeMemoryMatch
    warn("MM step 3: Done.")
    enableall()
end
-- ^^^
function getAllNectar(bool)
	if bool then
		local tablereturn = {}
		for i, v in pairs(nectarsDropdownTable) do
			table.insert(tablereturn, {name = v, time = getBuffTime(v, true)})
		end
		return tablereturn
	end
end

function useGlueDispenser()
    local gumdropsCount = getClientStatCache("Eggs", "Gumdrops")
    local used = false
    while canToyBeUsed("Glue Dispenser") and gumdropsCount and gumdropsCount > 0 do
        moveTo(Vector3.new(4, 87, 487))
        wait(0.5)
        if api.magnitude(Vector3.new(4, 87, 487)) > 0.75 then continue end
        gumdropsCount = getClientStatCache("Eggs", "Gumdrops")
        wait()
        PlayerActivesCommand:FireServer({["Name"] = "Gumdrops"})
        wait(0.5)
        while getClientStatCache("Eggs", "Gumdrops") == gumdropsCount do wait() end
        if api.magnitude(Vector3.new(272, 25260, -744)) > 30 then continue end
        api.humanoid():MoveTo(Vector3.new(270.8, 25257, -722.5))
        api.humanoid().MoveToFinished:Wait(2)
        wait(0.5)
        useToy("Glue Dispenser")
        used = true
    end
    if used then 
        player.Character:BreakJoints()
        player.CharacterAdded:Wait(10)
        wait(5)
    end
end

function getToys()
    for toysTableName, toysTable in pairs(AllToysTable) do
        for configToyName, toyName in pairs(toysTable) do 
            if toysTableName == "toysTable" and macrov2.toggles[configToyName]
            or toysTableName == "boostersTable" and macrov2.autoboostersettings[configToyName] and macrov2.toggles.autoboosters
            or toysTableName == "dispensersTable" and macrov2.autodispensersettings[configToyName] and macrov2.toggles.autodispensers
            then
                if toyName ~= "Glue Dispenser" then
                    useToy(toyName)
                else
                    useGlueDispenser()
                end
            elseif toysTableName == "beesmasToysTable" and macrov2.toggles[configToyName] and scriptType == "Paid" then
                useToy(toyName, true)
            elseif toysTableName == "memoryMatchTable" and macrov2.toggles.automemorymatch then
                useMemoryMatch(toyName)
            end
        end
    end
end

function lockMovement(bool)
    if bool then
        player.DevComputerMovementMode = Enum.DevComputerMovementMode.Scriptable
    else
        player.DevComputerMovementMode = Enum.DevComputerMovementMode.UserChoice
    end
end

function getCrosshairs()
    local crosshairs = {all = {}, purple = {}}
    for i,v in pairs(Workspace.Particles:GetChildren()) do
        if v.Name == "Crosshair" and findField(v.Position) == findField(api.humanoidrootpart().Position) then
            if not v:FindFirstChild("Collected") then
                if v.BrickColor == BrickColor.new("Red flip/flop") then
                    table.insert(crosshairs.all, v)
                elseif v.BrickColor == BrickColor.new("Alder") then
                    table.insert(crosshairs.all, v)
                    table.insert(crosshairs.purple, v)
                end
            end
        end
    end
    return {all = crosshairs.all, purple = crosshairs.purple}
end

function updateCrosshairs(shouldLock,exception) 
    for i,v in pairs(getCrosshairs().all) do
        if shouldLock and v ~= exception and v.BrickColor == BrickColor.new("Red flip/flop") then
            v.CanCollide = true
        elseif not shouldLock then
            v.CanCollide = false
        end
    end
end

function farmCrosshair(crosshair, save_height)
    local Path = PathfindingService:CreatePath({
		AgentRadius = 5,
        WaypointSpacing = 6,
		Costs = {
			Crosshair = math.huge
		}
	})
    updateCrosshairs(true, crosshair)
	Path:ComputeAsync(api.humanoidrootpart().Position, crosshair.Position)
	if Path then
		local points = Path:GetWaypoints()
        lockMovement(true)
		for _,v in pairs(points) do
            if (crosshair.Position - api.humanoidrootpart().Position).magnitude < 4 then break end
            if not crosshair.Parent or save_height ~= crosshair.Position.y then return lockMovement(false) end
			local moveComplete = false
			local startTime = tick()
			api.humanoid():MoveTo(v.Position)
			local signal
			signal = api.humanoid().MoveToFinished:Connect(function() moveComplete = true signal:Disconnect() end)
			repeat task.wait() until moveComplete or (tick() - startTime) > 0.85 or not crosshair.Parent or save_height ~= crosshair.Position.y or api.magnitude(crosshair.Position) < 5
		end
        lockMovement(false)
	end
    markAsCollected(crosshair)
    repeat wait() api.humanoid():MoveTo(crosshair.Position) until not crosshair.Parent or save_height ~= crosshair.Position.y
    updateCrosshairs(false)
end

function smartFarmCrosshairs()
    local buffStack = tonumber(getBuffStack("Precision"))
    local buffTime = tonumber(getBuffTime("Precision"))
    local isFarmed = false

    if (buffStack < 10 or buffTime <= 30) then
        for _,crosshair in pairs(getCrosshairs().all) do
            if not crosshair.Parent then continue end
            local MoveToFinished, started = false, tick()
            local save_height = crosshair.Position.y
            if crosshair.BrickColor == BrickColor.new("Forest green") or crosshair.BrickColor == BrickColor.new("Royal purple") then continue end
            lockMovement(true)
            api.humanoid():MoveTo(crosshair.Position)
            local signal
            signal = api.humanoid().MoveToFinished:Connect(function() MoveToFinished = true signal:Disconnect() end)
            repeat task.wait() until MoveToFinished or save_height ~= crosshair.Position.y or (tick() - started) > 5 or api.magnitude(crosshair.Position) < 4 or not crosshair.Parent
            lockMovement(false)
            markAsCollected(crosshair)
            isFarmed = true
        end
    elseif (buffStack == 10 and buffTime > 30) then
        for _,crosshair in pairs(getCrosshairs().purple) do
            if not crosshair.Parent then continue end
            local save_height = crosshair.Position.y
            if macrov2.autoFarmSettings.smartPreciseMethod == "Walk" then
                isFarmed = true
                farmCrosshair(crosshair, save_height)
            else
                repeat wait() 
                    if api.magnitude(crosshair.Position) > 5 then
                        tween(0.06,crosshair.Position - Vector3.new(0,1.8,0), true)
                    end
                until not crosshair.Parent or save_height ~= crosshair.Position.y or (#getCrosshairs().purple > 1)
                markAsCollected(crosshair)
                isFarmed = true
            end
            break
        end
    end
    return isFarmed
end

function getCooldownBySpawner(spawner)
    local spawnerInfo = monstersTable[spawner]
    local cooldownText,timer = "???"
    if spawnerInfo then
        local lastKillTime = ClientStatCache:Get({"MonsterTimes", spawner}) or 0
        local cooldown = (lastKillTime + spawnerInfo.RespawnCooldown) - math.floor(ServerTime())
        timer = cooldown
        if cooldown <= 0 then
            cooldownText = "‚úÖ"
        else
            cooldownText = truncatetime(cooldown)
        end
    end
    return cooldownText, timer
end

-- writefile("monters.json", jsonEncode(monstersTable))

function getSpawnedMonsters(mob)
    local respawnedMonsters = {}
    for i,v in pairs(monstersTable) do
        local lastKillTime = ClientStatCache:Get({"MonsterTimes", i}) or 0
        if (lastKillTime + v.RespawnCooldown) - math.floor(ServerTime()) < 30 then
            if not mob or mob == v.MonsterType then
                table.insert(respawnedMonsters, v)
            end
        end
    end
    return respawnedMonsters
end

function isMonsterKilled(mobSpawner)
    -- print(mobSpawner)
    for i,v in pairs(monstersTable) do
        if mobSpawner == v.Spawner.Name then
            local lastKillTime = ClientStatCache:Get({"MonsterTimes", i}) or 0
            if (lastKillTime + v.RespawnCooldown) - math.floor(ServerTime()) >= 0 then
                return true
            end
        end
    end
    return false
end

function killMonster(territory, spawner)
    local startTimeStamp = tick()
    temptable.doingMonster = true
    while not isMonsterKilled(spawner) do
        if (tick() - startTimeStamp) > 60 then break end
        -- print(not isMonsterKilled(spawner))
        if api.magnitude(territory.Position) > 30 then
            moveTo(territory.Position)
            wait(1)
        end
        jump()
        wait(2)
    end
    temptable.doingMonster = false
end

function killVicious()
    if macrov2.combatSettings.killVicious and temptable.detected.vicious then
        local viciousModel
        for i, v in pairs(Workspace.Particles:GetChildren()) do
            if v.Name:find("Vicious") then
                for i2, v2 in pairs(Workspace.Monsters:GetChildren()) do 
                    if v2.Name:find("Vicious") and v2:FindFirstChild("HumanoidRootPart") then
                        local level = tonumber(string.gmatch(v2.Name, "%d+")())
                        if level and level >= macrov2.combatSettings.viciousMinLevel and level <= macrov2.combatSettings.viciousMaxLevel then
                            viciousModel = v2
                            moveTo(v.Position + Vector3.new(0,3,0))
                            wait(0.5)
                        end
                    end
                end
            end
        end
        if viciousModel then
            local viciousOnField = findField(viciousModel.HumanoidRootPart.Position)
            -- warn(viciousOnField)
            local level = tonumber(string.gmatch(viciousModel.Name, "%d+")())
            while viciousModel and viciousOnField and viciousModel.Parent and macrov2.combatSettings.killVicious and temptable.detected.vicious and level and level >= macrov2.combatSettings.viciousMinLevel and level <= macrov2.combatSettings.viciousMaxLevel do
                if not viciousModel.Parent then viciousModel = nil break end
                if viciousOnField then
                    -- warn(findField(api.humanoidrootpart().Position))
                    if findField(api.humanoidrootpart().Position) ~= viciousOnField then
                        moveTo(viciousOnField.Position + Vector3.new(0,3,0))
                    end
                    if api.magnitude(viciousModel.HumanoidRootPart.Position) > 50 then
                        api.humanoid():MoveTo(viciousModel.HumanoidRootPart.Position)
                        wait(0.75)
                    end
                    collectNearestTokens(nil, 70)
                    avoidWarningDisks()
                end
                wait()
            end
        end
    end
end

function getQuestInfo(questName)
	setIdentity(2)
	local toReturn = Quests:Get(questName, getClientStatCache())
	setIdentity(7)
	return toReturn
end

function getQuestProgress(questName)
	setIdentity(2)
	local toReturn = Quests:Progress(questName, getClientStatCache())
	setIdentity(7)
	return toReturn
end

function getQuestSetting(npc, Type)
    return(npc == "Black Bear" and (Type == "prio" and macrov2.autoQuestSettings.BlackBearPriority or Type == "toggle" and macrov2.autoQuestSettings.BlackBearQuests))
       or (npc == "Brown Bear" and (Type == "prio" and macrov2.autoQuestSettings.BrownBearPriority or Type == "toggle" and macrov2.autoQuestSettings.BrownBearQuests))
       or (npc == "Panda Bear" and (Type == "prio" and macrov2.autoQuestSettings.PandaBearPriority or Type == "toggle" and macrov2.autoQuestSettings.PandaBearQuests))
       or (npc == "Science Bear" and (Type == "prio" and macrov2.autoQuestSettings.ScienceBearPriority or Type == "toggle" and macrov2.autoQuestSettings.ScienceBearQuests))
       or (npc == "Polar Bear" and (Type == "prio" and macrov2.autoQuestSettings.PolarBearPriority or Type == "toggle" and macrov2.autoQuestSettings.PolarBearQuests))
       or (npc == "Spirit Bear" and (Type == "prio" and macrov2.autoQuestSettings.SpiritBearPriority or Type == "toggle" and macrov2.autoQuestSettings.SpiritsBearQuests))
       or (npc == "Bucko Bee" and (Type == "prio" and macrov2.autoQuestSettings.BuckoBeePriority or Type == "toggle" and macrov2.autoQuestSettings.BuckoBeeQuests))
       or (npc == "Riley Bee" and (Type == "prio" and macrov2.autoQuestSettings.RileyBeePriority or Type == "toggle" and macrov2.autoQuestSettings.RileyBeeQuests))
       or (npc == "Honey Bee" and (Type == "prio" and macrov2.autoQuestSettings.HoneyBeePriority or Type == "toggle" and macrov2.autoQuestSettings.HoneyBeeQuests))
       or (npc == "Onett" and (Type == "prio" and macrov2.autoQuestSettings.OnettQuests or Type == "toggle" and macrov2.autoQuestSettings.OnettQuests))
       or (npc == "Bee Bear 5" and (Type == "prio" and macrov2.autoQuestSettings.BeeBearPriority or Type == "toggle" and macrov2.autoQuestSettings.BeeBearQuests))
       or (Type == "prio" and 100 or Type == "toggle" and false)
end

function prioritizeQuests(quests)
    local prioritizedQuests = {}
    local tempQuestsTable = {}
    for i,questData in pairs(quests) do
        local prio = getQuestSetting(questData.npc, "prio") or 101
        table.insert(tempQuestsTable, {prio, i, questData.Name})
    end
    table.sort(tempQuestsTable, function(a, b)
        if a[1] == b[1] then
            return a[2] < b[2]
        else
            return a[1] < b[1]
        end
    end)
    for i,v in pairs(tempQuestsTable) do
        table.insert(prioritizedQuests, v[3])
    end
    return prioritizedQuests
end

function getActiveQuests(NPC)
    local quests = {}
	for _, v in pairs(getClientStatCache("Quests", "Active")) do
		local quest = getQuestInfo(v.Name)
		local npc = quest.NPC
		if quest and not quest.Hidden then
			if (not NPC and getQuestSetting(npc, "toggle")) or (NPC and npc == NPC) then
				table.insert(quests, {Name = v.Name, npc = npc})
			end
		end
	end

    local questNames = prioritizeQuests(quests)

	return questNames
end

function collectNearestTokens(nearqui, magnitude)
    if not nearqui or typeof(nearqui) ~= "Vector3" then
        if (typeof(nearqui) == "Instance" and not nearqui.Position) then
            nearqui = nearqui.Position
        else
            nearqui = api.humanoidrootpart().Position
        end
    end

    for i,v in pairs(Workspace.Collectibles:GetChildren()) do
        if not v.Parent or not v.Position or table.find(temptable.susTokenPositions, v.Position) then continue end
        if api.magnitude(nearqui, v.Position) < (magnitude or 30)
        and api.magnitude(nearqui * Vector3.new(0,1,0), v.Position * Vector3.new(0,1,0)) < 10 then
            collectToken(v)
            wait()
        end
    end
end

function farmBubbles()
    local speedModified = false
    local bubblesToCollect = {}
    local bubbleRadius = macrov2.toggles
    for i,v in pairs(Workspace.Particles:GetChildren()) do
        if v.Name:find("Bubble") and findField(v.Position) == temptable.fieldSelected then
            if #bubblesToCollect == 0 then 
                if not macrov2.toggles.smartBlueAutofarm then
                    table.insert(bubblesToCollect, v)
                else
                    if temptable.fieldPosition and api.magnitude(temptable.fieldPosition, v.Position) < 30 then
                        table.insert(bubblesToCollect, v)
                    end
                end
            else
                -- print(#bubblesToCollect)
                -- Check for nearest bubbles
                if api.magnitude(v.Position, bubblesToCollect[#bubblesToCollect].Position) < 15 then
                    table.insert(bubblesToCollect, v)
                    -- print("bubble added,", #bubblesToCollect,"bubbles to collect")
                end
            end
        end
    end
    if #bubblesToCollect >= 3 then
        if temptable.speedMultiplier == 1 then speedModified = true temptable.speedMultiplier = 1.3 end
        for i,bubble in ipairs(bubblesToCollect) do
            repeat wait()
                api.humanoid():MoveTo(bubble.Position)
            until api.magnitude(api.humanoidrootpart().Position, bubble.Position) <= 14 or not macrov2.toggles.autofarm or not bubble.Parent
        end
    end
    if speedModified then temptable.speedMultiplier = 1 end
end

function farmShower()
    if #temptable.showersTable > 0 then
        while #temptable.showersTable > 0 do
            local key, warningisk = next(temptable.showersTable)
            if warningisk and warningisk.Parent and warningisk.Transparency > 0.09 then
                tween(0.05, warningisk.Position, true)
                repeat wait()
                until not warningisk.Parent or warningisk.Transparency <= 0.08
                temptable.showersTable[key] = nil
            else
                temptable.showersTable[key] = nil
            end
            wait()
        end
        for i=1,2 do
            collectNearestTokens()
        end
    end
end

function farmSprout(sprout, field)
    if not sprout or not sprout.Parent or not macrov2.autoFarmSettings.farmSprouts then return end

    local farmed = false

    while sprout and sprout.Parent and macrov2.autoFarmSettings.farmSprouts and macrov2.toggles.autofarm do
        -- print(findField(api.humanoidrootpart().Position), field)
        if getBagPercentage() >= 99 then
            convertHoney()
        end
        if findField(api.humanoidrootpart().Position) ~= field then
            moveTo(field.Position + Vector3.new(0,3,0))
            wait()
        end
        collectNearestTokens(field.Position, 60)
        farmed = true
        wait()
    end

    return macrov2.autoFarmSettings.farmSprouts and macrov2.toggles.autofarm and farmed 
end

function farmSprouts()
    if next(temptable.sproutsTable) then
        while next(temptable.sproutsTable) and macrov2.autoFarmSettings.farmSprouts and macrov2.toggles.autofarm do
            local key, sprout = next(temptable.sproutsTable)
            if sprout and sprout.Model.Parent then
                if farmSprout(sprout.Model, sprout.Field) then
                    for i = 1, 30 do
                        collectNearestTokens(sprout.Field.Position, 100)
                        wait()
                    end
                end
            else
                temptable.sproutsTable[key] = nil
            end
            wait()
        end
    end
end

function selectField(fieldName)
    if fieldName == nil then
        temptable.fieldSelected = nil
        temptable.fieldPosition = nil
        return "Unselected field"
    end
    if temptable.fieldSelected and temptable.fieldSelected.Name == fieldName then return "Field already selected" end
    temptable.fieldSelected = Workspace.FlowerZones[fieldName] or "Dandelion Field"
    temptable.fieldPosition = temptable.fieldSelected.Position
    -- print("Selected field "..fieldName)
end

-- whitelistedTasks = {
--     "Collect Pollen", 
--     "Collect Goo",
--     "Defeat Monsters",
--     "Use Items",
--     "Use Toy",
--     "Match Pairs",
--     "Complete Quests"
-- }

function getQuestTasks(NPC)
    NPC = NPC or false
    local quests = getActiveQuests(NPC)
    local defeatMonstersTasks = {} -- table to hold the "Defeat Monsters" tasks
    local tasksToDo = {}

    for _, quest in pairs(quests) do
        local questData = getQuestInfo(quest)
        local questName = questData.Name
        if not macrov2.autoQuestSettings.doRepeatables and questData.Repeatable then continue end

        for index, questTask in pairs(getQuestProgress(questName)) do
            local iscompleted = questTask[1]

            if iscompleted >= 1 then continue end

            local fullTask = questData.Tasks[index]

            local taskDescription = fullTask.Description
            if typeof(taskDescription) ~= "string" then 
                setIdentity(2)
                taskDescription = taskDescription(getClientStatCache()) 
                setIdentity(7)
            end

            local add = false

            if fullTask.Type == "Collect Pollen" and macrov2.autoQuestSettings.farmPollen
            or fullTask.Type == "Collect Goo" and macrov2.autoQuestSettings.farmGoo
            or fullTask.Type == "Defeat Monsters" and macrov2.autoQuestSettings.killMobs
            or fullTask.Type == "Use Toy" and macrov2.autoQuestSettings.useToys
            or fullTask.Type == "Match Pairs" and macrov2.autoQuestSettings.useMemoryMatch
            or fullTask.Type == "Complete Quests" and macrov2.autoQuestSettings.doQuestQuests
            or fullTask.Type == "Use Items" and taskDescription:find("Feed") and macrov2.autoQuestSettings.feedBees
            then
                add = true
            end

            if not add then continue end

            if fullTask.Type == "Defeat Monsters" then
                table.insert(defeatMonstersTasks, fullTask)
            else
                table.insert(tasksToDo, fullTask)
            end
        end
    end

    -- merge the defeatMonstersTasks table with the tasksToDo table
    if macrov2.autoQuestSettings.prioritizeMobKill then
        for _, task in ipairs(defeatMonstersTasks) do
            table.insert(tasksToDo, 1, task)
        end
    end

    return tasksToDo
end

function getQuestTaskField(questTask)
    if questTask.Type == "Collect Pollen" or questTask.Type == "Collect Goo" then
        if questTask.Zone then
            return questTask.Zone
        elseif questTask.Color then
            -- print(1, macrov2.autoQuestSettings["best"..questTask.Color.."Field"])
            return macrov2.autoQuestSettings["best"..questTask.Color.."Field"]
        end
    end
end

function claimQuests()
    for i, v in next, Workspace.NPCs:GetChildren() do
		if getQuestSetting(v.Name, "toggle") or 
        (macrov2.autoQuestSettings.acceptAllQuests and v.Name ~= "Honey Bee" and v.Name ~= "Gummy Bear" and v.Name ~= "Bubble Bee Man 2" and v.Name ~= "Ant Challenge Info" and v.Name ~= "Wind Shrine")
			and macrov2.autoQuestSettings.doQuests
		then
			local image = v.Platform.AlertPos.AlertGui.ImageLabel
			if image.ImageTransparency == 0 then
				doingquests = true
				if macrov2.toggles.tptonpc then
					api.humanoidrootpart().CFrame = CFrame.new(v.Platform.Position + Vector3.new(0,3,0))
				else
					moveTo(v.Platform.Position + Vector3.new(0,3,0))
                    wait(0.25)
				end

				local attempts = 0
				while image.ImageTransparency == 0 and api.magnitude(v.Platform.Position) < 25 and attempts < 5 do
					if api.magnitude(v.Platform.Position) <= 25 and not ScreenGui.NPC.Visible then
						while not ScreenGui.NPC.Visible and not (api.magnitude(v.Platform.Position) > 25) do
                            secureCall(ActivatablesNPC.ButtonEffect, Activatables, player, Workspace.NPCs[v.Name])
				             setIdentity(2)
							 ActivatablesNPC.ButtonEffect(player, Workspace.NPCs[v.Name])
                             setIdentity(7)
							wait(0.5)
						end
					end

					local tempTimestamp = tick()

					repeat wait() until ScreenGui.NPC.Visible or tick() - tempTimestamp > 10

					while ScreenGui.NPC.Visible do
						if ScreenGui.NPC.OptionFrame.Visible 
                          and ScreenGui.NPC.OptionFrame.Option2.Visible 
                          and ScreenGui.NPC.OptionFrame.Option2.Text:find("Talk to") then
                            setIdentity(2)
							firesignal(ScreenGui.NPC.OptionFrame.Option2.MouseButton1Click)
                            setIdentity(7)
						else
                            setIdentity(2)
							firesignal(ScreenGui.NPC.ButtonOverlay.MouseButton1Click)
                            setIdentity(7)
						end
						wait()
					end

					wait(2.5)
					attempts = attempts + 1
				end
				wait(0.5)
			end
		end
	end
end

function doQuests(NPC)
    NPC = NPC or false
    claimQuests()
    local questTasks = getQuestTasks(NPC)
    for taskIndex, questTask in pairs(questTasks) do
        -- print(questTask.Type, questTask.MonsterType, questTask.Amount)
        if questTask then
            local taskDescription = questTask.Description
            if typeof(taskDescription) ~= "string" then 
                setIdentity(2)
                taskDescription = taskDescription(getClientStatCache()) 
                setIdentity(7)
            end

            if questTask.Type == "Collect Pollen" or questTask.Type == "Collect Goo" then
                local newField = getQuestTaskField(questTask)
                if newField and Workspace.FlowerZones:FindFirstChild(newField) then
                    selectField(newField)
                    break
                end
            elseif questTask.Type == "Defeat Monsters" then
                local monsterToKill = questTask.MonsterType
                local numberOfMonsters = questTask.Amount
                local monsterSpawners = getSpawnedMonsters(monsterToKill)
                if #monsterSpawners > 0 then
                    for i,v in pairs(monsterSpawners) do
                        if numberOfMonsters < i then print("brk!") break end
                        if not isMonsterKilled(v.Spawner.Name) then
                            killMonster(v.Territory, v.Spawner.Name)
                            wait(1)
                            for i=1,5 do
                                collectNearestTokens(nil, 20)
                            end
                        end
                    end
                end
            elseif questTask.Type == "Use Items" then
                if false and not string.find(taskDescription, "Feed") and not questTask.Item:find("Jelly") then
                    --UseItem
                    if not useItemCooldown then
                        game:GetService("ReplicatedStorage").Events.PlayerActivesCommand:FireServer({["Name"]=questTask.Item})
                        task.spawn(function()
                            useItemCooldown = true
                            task.wait(100)
                            useItemCooldown = false                        
                        end)
                    end
                elseif string.find(taskDescription, "Feed") then
                    --Feed
                    Events.ClientCall("ConstructHiveCellFromEgg", math.random(1,5), 1, questTask.Item, questTask.Amount, false)
                end
            elseif questTask.Type == "Use Toy" then
                if canToyBeUsed(questTask.Toy) then
                    if not questTask.Toy:find("Glue") then
                        useToy(questTask.Toy)
                    else
                        useGlueDispenser()
                    end
                end
            elseif questTask.Type == "Match Pairs" then
                for i,v in pairs(AllToysTable["memoryMatchTable"]) do
                    useMemoryMatch(v, true)
                end
            elseif questTask.Type == "Complete Quests" then
                doQuests(questTask.Pool or "Polar Bear")
            end
        end
    end
end

function trainTunnelBear()
    if macrov2.combatSettings.trainTunnelBear then
        if #getSpawnedMonsters("Tunnel Bear") == 1 then
            tunnelPart.CanCollide = true
            local spawner = getSpawnedMonsters("Tunnel Bear")[1].Spawner
            while macrov2.combatSettings.trainTunnelBear and not isMonsterKilled(spawner.Name) do
                if api.magnitude(tunnelPart.Position) > 10 then
                    moveTo(tunnelPart.Position + Vector3.new(0,3,0))
                    wait()
                end
                wait(0.1)
            end
            tunnelPart.CanCollide = false
            wait(1)
            if #getSpawnedMonsters("Tunnel Bear") == 0 then
                wait(0.5)
                for i=1,10 do
                    if api.magnitude(tunnelPart.Position) > 250 then
                        moveTo(tunnelPart.Position - Vector3.new(0,15,0))
                    end
                    collectNearestTokens(nil, 200)
                end
                wait(0.5)
            end
        end
    end
end

function trainCrab()
    if macrov2.combatSettings.trainCrab then
        if #getSpawnedMonsters("Coconut Crab") == 1 then
            local coconutField = Workspace.FlowerZones["Coconut Field"]
            local oldMask = getClientStatCache("EquippedAccessories", "Hat")
            if oldMask ~= "Demon Mask" and oldMask ~= "Gummy Mask" then
                requestAccessoryEquip("Demon Mask")
            end
            print("Started Crab Training")
            cocoPad.CanCollide = true
            local spawner = getSpawnedMonsters("Coconut Crab")[1].Spawner
            while macrov2.combatSettings.trainCrab and not isMonsterKilled(spawner.Name) do
                if api.magnitude(Vector3.new(-258, 109, 483)) > 50 then
                    moveTo(Vector3.new(-441, 123, 498))
                    wait(6)
                    moveTo(Vector3.new(-258, 109, 483))
                    wait()
                elseif api.magnitude(Vector3.new(-258, 109, 483)) > 15 then
                    api.humanoid():MoveTo(Vector3.new(-258, 109, 483))
                    api.humanoid().MoveToFinished:Wait(2)
                end
                if api.magnitude(Vector3.new(-258, 109, 483)) < 20 then
                    collectNearestTokens(Vector3.new(-258, 109, 483), 20)
                end
                wait()
            end
            cocoPad.CanCollide = false
            if #getSpawnedMonsters("Coconut Crab") == 0 then
                wait(1)
                for i=1,25 do
                    if findField(player.Character.HumanoidRootPart.Position) ~= coconutField then
                        moveTo(coconutField.Position + Vector3.new(0,3,0))
                    end
                    collectNearestTokens(coconutField.Position, 50)
                end
                wait(0.5)
            end
            if oldMask == "Diamond Mask" then
                requestAccessoryEquip("Diamond Mask")
            end
        end
    end
end

function trainKingBeetle()
    if macrov2.combatSettings.trainKingBeetle then
        if #getSpawnedMonsters("King Beetle") == 1 then
            local spawner = getSpawnedMonsters("King Beetle")[1].Spawner

            while macrov2.combatSettings.trainKingBeetle and not isMonsterKilled(spawner.Name) do
                if api.magnitude(Vector3.new(179, 4, 194)) > 100 then
                    moveTo(Vector3.new(172, 4, 144))
                    wait(1)
                    -- moveTo(Vector3.new(108, 4, 227))
                    -- wait()
                    api.humanoid():MoveTo(Vector3.new(109, 4, 253))
                end
                wait()
            end

            wait(1)

            if #getSpawnedMonsters("King Beetle") == 0 then
                for i=1,10 do
                    collectNearestTokens(Vector3.new(179, 4, 194), 60)
                end
                wait(0.5)
            end
        end
    end
end

function isFieldOccupied(field)
    local planters = getMinePlanters()
    for _,planter in pairs(planters) do
        if planter.PotModel and planter.PotModel.Parent and planter.PotModel.PrimaryPart then
            if findField(planter.PotModel.PrimaryPart.Position).Name == field then
                return true
            end
        end
    end
    return false
end

function isPlanterPlanted(planterName)
    local planters = getMinePlanters()
    for _,planter in pairs(planters) do
        if planter.Active and not planter.Collected and planter.Type == planterName then
            return true
        end
    end
    return false
end

function getBestPlanter(nectar, field, blacklisted)
    local bestPlanter = ""
    local bestZone = ""
    local bestNectarMultiplier = 0
    local bestZoneMultiplier = 0

    for planterName, planter in pairs(plantersTable) do
        if not table.find(macrov2.autoPlantersSettings.blacklistedPlanters, planter.systemName) 
        and not isPlanterPlanted(planterName) 
        and (planterName ~= "Plenty" and getClientStatCache("Eggs", planterName.."Planter") or getClientStatCache("Eggs", "The Planter Of Plenty")) then
            local fieldColor = Workspace.FlowerZones[field].ColorGroup.Value
            local nectarMultiplier = planter.nectarMultipliers[nectar] or 1
            local zoneMultiplier = planter.pollenMultipliers.Zones[fieldColor] or 1
            local colorMultiplier = planter.pollenMultipliers.Colors[fieldColor] or 1
            local overallMultiplier = nectarMultiplier * zoneMultiplier * colorMultiplier

            if overallMultiplier > bestNectarMultiplier * bestZoneMultiplier then
                bestPlanter = planterName
                bestZone = fieldColor
                bestNectarMultiplier = nectarMultiplier
                bestZoneMultiplier = zoneMultiplier * colorMultiplier
            end
        end
    end

    return bestPlanter, bestZone
end

function isNectarPending(nectartype)
	local planters = getMinePlanters()
	for i, v in pairs(planters) do
		local location = findField(v.PotModel.PrimaryPart.Position)
		if location then
			local conftype = NectarTypes.PickForField(location.Name)
			if conftype then
				if conftype.." Nectar" == nectartype then
					return true
				end
			end
		end
	end
	return false
end

function getBestNectarField(nectar)
    local nectar = nectar:gsub(" Nectar", "")
    if not nectarsTable[nectar] then return --[[warn(nectar, "not found")]] end
    local bestField = ""
    for index, nectarField in pairs(nectarsTable[nectar]) do
        if not isFieldOccupied(nectarField) and not (nectarField == "Ant Field") then
            bestField = nectarField
        end
    end
    return bestField
end

function calculateLeastNectar()
    local blacklistedNectars = macrov2.autoPlantersSettings.blacklistedNectars
    local leastNectar
    local leastNectarTime = math.huge
    for i,v in pairs(nectarsDropdownTable) do
        if table.find(blacklistedNectars, v) or isNectarPending(v) then continue end
        -- print(table.find(blacklistedNectars, v), isNectarPending(v))
        local currentNectarTime = getBuffTime(v)
        if currentNectarTime < leastNectarTime then
            leastNectar = v
            leastNectarTime = currentNectarTime
        end
    end
    -- warn(leastNectar)
    return leastNectar
end

function collectSpecificPlanter(planterPart, id)
    if planterPart and api.humanoid() and api.humanoid().Health > 0 and api.humanoidrootpart() then
        moveTo(planterPart.Position)
        wait(1)
        if api.magnitude(api.humanoidrootpart().Position, planterPart.Position) < 20 then
            setIdentity(2)
            Events.ClientCall("PlanterModelCollect", id)
            -- LocalPlanters.PromptCollect(id)
            setIdentity(7)
            wait(3)
            for i = 1, 10 do
                collectNearestTokens(nil, 50)
            end
            wait()
        end
    end
end

if _G.debugging then
    warn("Functions init done. Waiting 1 second")
    wait(1)
end

if _G.debugging then
    warn("Other Functions init.")
end

-- writefile("plantersData.json", jsonEncode(plantersTable))

function isPlanterExists(pNum)
	local exists = false
	local stuffs = getMinePlanters()
	if stuffs ~= {} then
		for i, v in pairs(stuffs) do
			if v["ActorID"] == pNum and v.Active and not v.Collected then
				exists = true
			end
		end
	end
	return exists
end

function plantPlanter(planterName, fieldName)
    if not planterName or not fieldName then return end
    local fieldSelected = Workspace.FlowerZones:FindFirstChild(fieldName)
    if not fieldSelected then return end
    temptable.plantingPlanter = true
    if api.humanoidrootpart() and api.humanoid().Health > 0 then
        while not (api.magnitude(fieldSelected.Position) < 8) do
            moveTo(fieldSelected.Position + Vector3.new(0,3,0))
            wait()
        end
        wait(1)
        warn(planterName, fieldName)
        PlayerActivesCommand:FireServer({["Name"] = plantersTable[planterName].displayName})
    end
end

function collectAllPlanters(collectPercentage)
    local plantersToCollect = {}
    for _,planter in pairs(getMinePlanters()) do
        if planter.GrowthPercent ~= nil then
            
            if planter.GrowthPercent >= ((collectPercentage or macrov2.autoPlantersSettings.planterHarvestAt) / 100) then
                table.insert(plantersToCollect, {
                    ["PM"] = planter["PotModel"].PrimaryPart,
					["AID"] = planter["ActorID"]
                })
            end
        end
    end
    if #plantersToCollect > 0 then
        for _,planter in pairs(plantersToCollect) do
            while isPlanterExists(planter.AID) do
                collectSpecificPlanter(planter.PM, planter.AID)
                wait(1)
            end
        end
    end
end

function farmPlanters()
    if macrov2.autoPlantersSettings.doCustomPlanters then
        if not isfile(planterCacheDirectory.."/customPlanterSteps.json") then
            while #getMinePlanters() > 0 do
                collectAllPlanters(0)
                wait()
            end
            local newSteps = {customPlanters1 = 1, customPlanters2 = 1, customPlanters3 = 1}
            writefile(planterCacheDirectory.."/customPlanterSteps.json", jsonEncode(newSteps))
        end
        local planterCycles = macrov2.customPlanterSettings

        local steps = {
            customPlanters1 = 5, 
            customPlanters2 = 5, 
            customPlanters3 = 5
        }

        for cycleName,stepsTable in pairs(planterCycles) do
            for step, stepTable in pairs(stepsTable) do
                if (not stepTable.planter or not table.find(plantersDropdownTable, stepTable.planter))
                 or not stepTable.field or not table.find(fieldsTable, stepTable.field) then
                    steps[cycleName] -= 1
                end
            end
        end
        local currentSteps = jsonDecode(readfile(planterCacheDirectory.."/customPlanterSteps.json"))

        for cycleName, step in pairs(currentSteps) do
            if tonumber(step) > steps[cycleName] then
                collectAllPlanters()
                local newSteps = {customPlanters1 = 1, customPlanters2 = 1, customPlanters3 = 1}
                writefile(planterCacheDirectory.."/customPlanterSteps.json", jsonEncode(newSteps))
                currentSteps = newSteps
            end
        end
        for cycleName, stepsTable in pairs(planterCycles) do
            if steps[cycleName] == 0 then continue end
            local planted = false
            local currentStep = tonumber(currentSteps[cycleName]) or 1
			currentStep = (currentStep - 1) % steps[cycleName] + 1
            for stepIndex, step in pairs(stepsTable) do
                if step.planter and step.field and tonumber(step.harvestAmount) 
                and table.find(fieldsTable, step.field) and table.find(plantersDropdownTable, step.planter) then
                    for i, planter in pairs(getMinePlanters()) do
                        -- print(planter.GrowthPercent, step.harvestAmount / 100)
                        if planter.GrowthPercent >= (step.harvestAmount / 100) then
                            if planter.PotModel.Name == step.planter and findField(planter.PotModel.PrimaryPart.Position).Name == step.field then
                                collectSpecificPlanter(planter.PotModel.PrimaryPart, planter.ActorID)
                            end
                        else
                            if planter.PotModel.Name == step.planter and findField(planter.PotModel.PrimaryPart.Position).Name == step.field then
                                planted = true
                            end
                        end
                    end
                end
            end
            if not planted and stepsTable[currentStep].planter and #getMinePlanters() < 3 then
                local planter = stepsTable[currentStep].planter
                local planterData = getPlanterData(planter)
                local planterSystemName = planterData.systemName.."Planter"
                local planterDisplayName = planterData.displayName
                local planterCount = getClientStatCache("Eggs", planterSystemName) or 0
                -- print(planterSystemName, planterDisplayName)
                if planterCount > 0 then
                    plantPlanter(planterData.systemName, stepsTable[currentStep].field)
                    currentSteps[cycleName] = tostring((currentStep - 1) % steps[cycleName] + 2)
                    writefile(planterCacheDirectory.."/customPlanterSteps.json", jsonEncode(currentSteps))
                end
            end
        end
    else
        if macrov2.toggles.autofarm and not temptable.convertingHoney then
            -- print("Collecting")
            collectAllPlanters()
            if #getMinePlanters() < 3 then
                local LeastNectar = calculateLeastNectar()
                local Field = getBestNectarField(LeastNectar)
                if LeastNectar and Field ~= "" then
                    local Planter = getBestPlanter(LeastNectar,Field)
                    if LeastNectar and Field and Planter ~= "" then
                        plantPlanter(Planter, Field)
                    end
                else
                    warn(Field, LeastNectar)
                end
            end
        end
    end
end

function webhookFieldsList()
    local currentHoney = getClientStatCache("Totals","Honey")
	local timePassed = math.round(tick() - currentMacroV2LoadedAt)
    -- print(currentHoney, temptable.honeyAtStart)
	local honeyGained = currentHoney - temptable.honeyAtStart
    -- print(currentHoney, timePassed, honeyGained)

    local honeyPerHour = math.floor(honeyGained / timePassed) * 3600
    local dailyHoney = getDailyHoney()

	local totalHoneyString = truncate(currentHoney)
	local honeyGainedString = truncate(honeyGained)
	local honeyPerHourString = truncate(honeyPerHour)
	local honeyPerDayString = truncate(dailyHoney)

	if not macrov2.webhookSettings.onlyTruncated then
		totalHoneyString = addcommas(currentHoney).." ("..totalHoneyString..")"
		honeyGainedString = addcommas(honeyGained).." ("..honeyGainedString..")"
		honeyPerHourString = addcommas(honeyPerHour).." ("..honeyPerHourString..")"
		honeyPerDayString = addcommas(dailyHoney).." ("..honeyPerDayString..")"
	end

	local uptimeString = truncatetime(timePassed)
	local fields = {}

    if macrov2.webhookSettings.showTotalHoney then
		table.insert(fields, {
			["name"] = "Total Honey:",
			["value"] = totalHoneyString,
			["inline"] =  false
		})
	end
	table.insert(fields, {
		["name"] = "Session Honey:       ",
		["value"] = honeyGainedString,
		["inline"] =  true
	})
	table.insert(fields, {
		["name"] = "Session Uptime:     ",
		["value"] = uptimeString,
		["inline"] =  true
	})
	if macrov2.webhookSettings.showHoneyPerHour then
		table.insert(fields, {
			["name"] = "Honey Per Hour:       ",
			["value"] = honeyPerHourString,
			["inline"] = false
		})
	end
    if macrov2.webhookSettings.showDailyHoney then
		table.insert(fields, {
			["name"] = "Honey Per Day:     ",
			["value"] = honeyPerDayString,
			["inline"] = false
		})
	end
	if macrov2.webhookSettings.showNectars then
		local nectars = getAllNectar(true)
		local nectarsString = ""
		for index, nectar in pairs(nectars) do
			if nectar.time == 0 then continue end
			nectarsString = nectarsString..""..(nectarEmojis[nectar.name] or nectar.name..":").." "..nectar.time
			nectarsString = nectarsString.."\n"
		end
		if #nectarsString > 1 then
			table.insert(fields, {
				["name"] = "Nectars:",
				["value"] = nectarsString,
				["inline"] =  false
			})
		end
	end
	if macrov2.webhookSettings.showPlanters then
		local plantersString = ""
        pcall(function()
            local minePlanters = getMinePlanters()
            for i,v in pairs(minePlanters) do
                plantersString = plantersString..""..plantersEmojis[v.PotModel.Name].." "..math.floor(v.GrowthPercent*1000)/10 .. "%\n"
            end
        end)
        if plantersString ~= "" then
            table.insert(fields, {
                ["name"] = "Active Planters",
                ["value"] = plantersString,
                ["inline"] = false
            })
        end
	end
	if macrov2.webhookSettings.showItems then
		local itemsString = ""
		for index, item in pairs(macrov2.webhookSettings.itemsList) do
			local systemItem = getItemByName(item)
			if systemItem and systemItem.SystemName then 
				local systemName = systemItem.SystemName
				local count = getClientStatCache("Eggs", systemName) or 0
				itemsString = itemsString .. item .. ": **" .. tostring(count) .. "**\n"
			end
		end
		if itemsString ~= "" then
			table.insert(fields, {
				["name"] = "Items Per Hours:",
				["value"] = itemsString,
				["inline"] = false
			})
		end
	end
	return fields
end

function generateWebhookBody(settings)
	local body = {
		["username"] = player.Name,
		["avatar_url"] = "https://cdn.discordapp.com/icons/1024873171867942933/a_6704e7f2ca7cee2f8b9ea7a90891cf57.gif?size=48",
		["content"] = settings.content or "",
		["embeds"] = {{
			["title"] = "**"..settings.embedTitle.."**",
			["description"] = settings.embedDescription or "",
			["type"] = "rich",
			["color"] = tonumber(settings.color) or tonumber(macrov2.webhookSettings.webhookColor),
			["thumbnail"] = {url = settings.thumbnail or "https://cdn.discordapp.com/icons/1024873171867942933/a_6704e7f2ca7cee2f8b9ea7a90891cf57.gif?size=96"},
			["fields"] = settings.fields or {},
			["footer"] = {
				["text"] = os.date("%x").." ‚Ä¢ "..os.date("%I")..":"..os.date("%M")..--[[":"..os.date("%S")..]]" "..os.date("%p")
			}
		}}
	}
	return body
end

function sendWebhook(body)
	local headers = {
		["content-Type"] = "application/json"
	}
    local success, response = pcall(function()
        httpreq({
            Url = macrov2.webhookSettings.webhookUrl, 
            Body = HttpService:JSONEncode(body), 
            Method = "POST", 
            Headers = headers
        })
    end)
    if not success then 
        warn("Failed to send webhook:", response) 
    else
        temptable.lastWebhookSent = math.round(tick())
    end
end

function questWebhook(quest,fields)
	local thumbnail = npcsIcons[quest]
	local data = generateWebhookBody({
		embedTitle = "Macro V2 | Quests",
		thumbnail = thumbnail,
		fields = fields
	})
	sendWebhook(data)
end

function sendHourlyWebhook(isTest)
    local ping = macrov2.webhookSettings.pingUser and "<@"..macrov2.webhookSettings.discordId..">" or ""
	local data = generateWebhookBody({
		content = (isTest and ping ~= "" and ping..", your webhook is working!") or (isTest and ping == "" and "Your webhook is working!") or ping,
		embedTitle = isTest and "Webhook Test" or "Honey Update",
		fields = webhookFieldsList()
	})
    -- writefile("datanew.json", game.HttpService:JSONEncode(data))
	-- print("sending webhook")
	sendWebhook(data)
end

function sendTestWebhook()
    local data = generateWebhookBody({
		embedTitle = "Test Webhook",
        embedDescription = "Hey lol - Narnia"
	})
    sendWebhook(data)
end

if _G.debugging then
    warn("Other Functions init done. Waiting 5 seconds")
    wait(5)
end

if _G.debugging then
    warn("Auto Memory Match init.")
end

if not getgenv().autoMMConfigured then
getgenv().autoMMConfigured = true
LPH_NO_VIRTUALIZE(function() -- Auto Memory Match
    local MemoryMatchStartGame = MinigameGui.StartGame
    
    local function UpdateGameTable(a)
        local dupes = {}
        local exclude = a.Game.MatchedTiles
    
        for index, value in pairs(a.Game.RevealedTiles) do
            if exclude[index] == nil then  -- skip excluded indexes
                if dupes[value] == nil then
                    dupes[value] = {Indexes = {index}}
                else
                    table.insert(dupes[value]["Indexes"], index)
                end
            end
        end
    
        for i,v in pairs(dupes) do
          if #v.Indexes < 2 then dupes[i] = nil end
        end
    
        return dupes
    end
    
    function newMemoryMatchStartGame(a)
        if not macrov2.toggles.automemorymatch and not macrov2.autoQuestSettings then return end
        repeat wait() until a and a.Game and a.Game.Grid and a.Game.Grid.InputActive
        temptable.activeMemoryMatch = a
        --print("You have",a.Game.Chances,"Chances")
        for Index = 1, a.Game.NumTiles do
            wait()
            warn("You have",a.Game.Chances,"chances left")
            if a.Game.Chances == 0 then break end
            setIdentity(2)
            local tile = a.Game.Grid:GetTileAtIndex(Index)
            setIdentity(7)
    
            if a.Game.LastSelectedIndex ~= nil then
                local searchFor = a.Game.RevealedTiles[a.Game.LastSelectedIndex]
                local dupes = UpdateGameTable(a)
                -- print(searchFor)
                for i2,v2 in pairs(dupes) do
                    if i2 == searchFor and v2.Indexes[1] ~= Index then 
                        setIdentity(2)
                        tile = a.Game.Grid:GetTileAtIndex(v2.Indexes[1]) --[[print("found matched tile")]] 
                        setIdentity(7)
                        break 
                    end
                end
            else
                local dupes = UpdateGameTable(a)
                for i,v in pairs(dupes) do
                    if #v.Indexes > 1 then
                        -- secureCall(MemoryMatchModule.RegisterTileSelected, MemoryMatchGui, a.Game, a.Game.Grid:GetTileAtIndex(v.Indexes[1]))
                        setIdentity(2)
                        MemoryMatchModule.RegisterTileSelected(a.Game, a.Game.Grid:GetTileAtIndex(v.Indexes[1]))
                        setIdentity(7)
                        repeat wait() until a.Game.Grid.InputActive or a.Game.Chances <= 0
                        setIdentity(2)
                        tile = a.Game.Grid:GetTileAtIndex(v.Indexes[2])
                        setIdentity(7)
                        wait()
                        break
                    end
                end
            end
            -- secureCall(MemoryMatchModule.RegisterTileSelected, MemoryMatchGui, a.Game, tile)
            setIdentity(2)
            MemoryMatchModule.RegisterTileSelected(a.Game, tile)
            setIdentity(7)
            repeat wait() until a.Game.Grid.InputActive or a.Game.Chances <= 0
            wait()
        end
        warn("Finishing memory Match")
        -- secureCall(MemoryMatchModule.Finish, a.Game)
        -- MemoryMatchModule.Finish(a.Game)
        Events.ClientCall("MemoryMatchEvent", {
            Action = "Finish"
        })
        warn("Ending Game")
        -- secureCall(MinigameGui.EndGame, MemoryMatchManager)
        setIdentity(2)
        MinigameGui.EndGame()
        setIdentity(7)
        warn("Game ended successfully")
        temptable.activeMemoryMatch = nil
    end
    local hookedMemoryMatchStartGame; hookedMemoryMatchStartGame = hookfunction(MemoryMatchStartGame, function(...)
        local a = hookedMemoryMatchStartGame(...)
        spawn(function() wait(1) newMemoryMatchStartGame(a) end)
        return a
    end)
end)()
end

function questWebhookListener(name,quest)
	if macrov2.autoQuestSettings.sendWebhook then
		if name == "CompleteQuest" or name == "CompleteQuestFromPool" then 
			spawn(function() 
				local ppower = tosstring(getClientStatCache("Modifiers", "MaxBeeEnergy", "_", "Mods", 1, "Combo") or 0)
				questWebhook(quest,{
					{
						name = "Completed Quest",
						value = quest..(quest=="Polar Bear"and"\n\n<:PolarPower:1080979354030444594> x"..ppower or"")
					}
				})
			end)
		end
	end
end

function placeSprinkler(position, withoutWait, withoutJump)
    -- Place a sprinkler at the specified position
    local humanoid = api.humanoid()
    walkTo(position, 2)
    if not withoutJump then
        wait(.1)
        humanoid.Jump = true
        wait(.2)
    end
    PlayerActivesCommand:FireServer({["Name"] = "Sprinkler Builder"})
    if not withoutWait then
        wait(1)
    end
end

local sprinklerCounts = {
    ["The Supreme Saturator"] = 1,
    ["Basic Sprinkler"] = 1,
    ["Silver Soakers"] = 2,
    ["Golden Gushers"] = 3,
    ["Diamond Drenchers"] = 4
}

function placeSprinklers(fieldPos)
    if not fieldPos then return end
    print("sprinklers")
    local sprinkler = getClientStatCache("EquippedSprinkler")
    local flowerSize = 4

    local sprinklersToPlace = sprinklerCounts[sprinkler] or 0
    local placedSprinklersCount = 0

    local centerPos = fieldPos

    for _,v in pairs(Workspace.Gadgets:GetChildren()) do
        if v.Name == sprinkler and isFieldSame(centerPos, v.Base.Position) then
            placedSprinklersCount += 1
        end
    end

    if placedSprinklersCount >= sprinklersToPlace then return --[[print("sprinklers already placed!")]] end

    -- Check number of sprinklers to place and use appropriate pattern
    if sprinklersToPlace == 1 then
        -- Place one sprinkler in the center
        placeSprinkler(centerPos, true, true)
    elseif sprinklersToPlace == 2 then
        -- Place two sprinklers in a diagonal pattern
        placeSprinkler(centerPos + Vector3.new(-3*flowerSize, 0, -3*flowerSize))
        placeSprinkler(centerPos + Vector3.new(3*flowerSize, 0, 3*flowerSize), true, false)
    elseif sprinklersToPlace == 3 then
        -- Place three sprinklers in a "T" pattern
        placeSprinkler(centerPos + Vector3.new(3*flowerSize, 0, -3*flowerSize))
        placeSprinkler(centerPos + Vector3.new(-4*flowerSize, 0, -3*flowerSize))
        placeSprinkler(centerPos + Vector3.new(0*flowerSize, 0, 3*flowerSize), true, false)
    elseif sprinklersToPlace == 4 then
        -- Place four sprinklers in a "square" pattern
        placeSprinkler(centerPos + Vector3.new(-4*flowerSize, 0, 0*flowerSize))
        placeSprinkler(centerPos + Vector3.new(4*flowerSize, 0, 0*flowerSize))
        placeSprinkler(centerPos + Vector3.new(0*flowerSize, 0, 4*flowerSize))
        placeSprinkler(centerPos + Vector3.new(0*flowerSize, 0, -4*flowerSize), true, false)
    end
end

-- Auto Royal Jelly Functions
function getBeeRarity(beeName)
    local fullBeeData = beesTable.fullData[beeName:gsub(" Bee", "")]
    if fullBeeData then return fullBeeData.Rarity end
    return "Error 401 :skull:"
end

function isBeeExpected(beeCell)
    local beeName = beeCell.CellType.Value:gsub("Bee", " Bee")
    local beeRarity = getBeeRarity(beeName)
    local isGifted = beeCell:FindFirstChild("GiftedCell") and true or false
    
    local stop = false

    if temptable.autoRJSettings.requireAnyGifted and isGifted then 
        stop = true 
    end

    if table.find(temptable.autoRJSettings.selectedRarities, "Any "..beeRarity) or table.find(temptable.autoRJSettings.selectedRarities, "Gifted Any "..beeRarity) and isGifted then
        stop = true
    end

    if table.find(temptable.autoRJSettings.selectedBees, beeName) or table.find(temptable.autoRJSettings.selectedBees, "Gifted "..beeName) and isGifted then
        stop = true
    end
    return stop
end

function useJelly(x, y)
    -- secureCall(Events.ClientCall, ReplicatedStorage.Events, x, y, "RoyalJelly")
    Events.ClientCall("ConstructHiveCellFromEgg", x, y, "RoyalJelly")
    -- game:GetService("ReplicatedStorage").Events.ConstructHiveCellFromEgg:InvokeServer(x, y, "RoyalJelly") 
end

function startAutoRJ() 
    temptable.autoRJSettings.runningAutoRJ = true
    local x,y = temptable.autoRJSettings.xCoord,temptable.autoRJSettings.yCoord
    local cell = plrHive.Cells[("C%s,%s"):format(x, y)]
    --[[print(cell)]]
    while not isBeeExpected(cell) and temptable.autoRJSettings.runningAutoRJ do
        useJelly(x, y)
    end
end

function stopAutoRJ() 
    temptable.autoRJSettings.runningAutoRJ = false 
end

if _G.debugging then
    warn("Memory Match init done. Waiting 5 seconds")
    wait(5)
end

if _G.debugging then
    warn("Loading UI")
end

UIConfig = {
    WindowName = "Macro V2 - v"..temptable.version.." Made By Narnia",
    Keybind = _G.keybind and Enum.KeyCode[_G.keybind] or Enum.KeyCode.Semicolon
}

Window = library:Init(UIConfig)

if _G.debugging then
    warn("UI loaded. waiting 5 seconds")
    wait(5)
end

guiElements = {
    toggles = {},
    vars = {},
    bestfields = {},
    autodispensersettings = {},
    autoboostersettings = {},
    autoQuestSettings = {},
    webhookSettings = {},
    autoPlantersSettings = {},
    blacklistedNectars = {},
    autoPuffshroomSettings = {},
    combatSettings = {},
    autoFarmSettings = {},
    alertSettings = {},
    convertSettings = {}
}

function createTab(name)
    return Window:Tab(name)
end

function createSection(tab, sectionName)
    return tab:Section(sectionName)
end

function createLabel(section, labelText)
    return section:Label(labelText)
end

function updatedLabel(label, newText)
    return label:Set(newText)
end

function createDropdown(section, dropDownText, dropDownTable, config, callback)
    if callback == true then 
        callback = function(Option) 
            -- warn("selected", (config[1] and config[1].."/"..config[2] or config), "to", Option)
            if typeof(config) == "table" then
                macrov2[config[1]][config[2]] = Option
            elseif typeof(config) == "string" then
                macrov2.vars[config] = Option
            end
        end
    end
    local newDropdown = section:Dropdown(dropDownText, dropDownTable, callback)
    if config then
        if typeof(config) == "table" then
            -- print(config[2])
            guiElements[config[1]][config[2]] = newDropdown
        elseif typeof(config) == "string" then
            guiElements.vars[config] = newDropdown
        end
    end
    return newDropdown
end

function createToggle(section, toggleText, config, callback)
    if callback == true then 
        callback = function(state) 
            -- warn("toggled", (config[1] and config[1].."/"..config[2] or config), "to", state)
            if typeof(config) == "table" then
                macrov2[config[1]][config[2]] = state
            elseif typeof(config) == "string" then
                macrov2.toggles[config] = state
            end
        end
    end
    local newToggle = section:Toggle(toggleText, callback)
    if config and typeof(config) == "string" then
        guiElements["toggles"][config] = newToggle
    elseif config and typeof(config) == "table" then
        guiElements[config[1]][config[2]] = newToggle
    end
    return newToggle
end

function createSlider(section, sliderText, settings, config, callback)
    if callback == true then
        callback = function(newValue)
            -- warn("changed", (config[1] and config[1].."/"..config[2] or config), "to", newValue)
            if typeof(config) == "table" then
                macrov2[config[1]][config[2]] = newValue
            elseif typeof(config) == "string" then
                macrov2.vars[config] = newValue
            end
        end
    end
    local newSlider = section:Slider(sliderText, callback, settings)
    if config and typeof(config) == "string" then
        guiElements["vars"][config] = newSlider
    elseif config and typeof(config) == "table" then
        guiElements[config[1]][config[2]] = newSlider
    end
    return newSlider
end

function createInput(section, inputText, inputPlaceholder, config, callback)
    if callback == true then
        callback = function(newValue)
            -- warn("changed", (config[1] and config[1].."/"..config[2] or config), "to", newValue)
            if typeof(config) == "table" then
                macrov2[config[1]][config[2]] = newValue
            elseif typeof(config) == "string" then
                macrov2.vars[config] = newValue
            end
        end
    end
    local newInput = section:Box(inputText, inputPlaceholder, callback)
    if config and typeof(config) == "string" then
        guiElements["vars"][config] = newInput
    elseif config and typeof(config) == "table" then
        guiElements[config[1]][config[2]] = newInput
    end
    return newInput
end

function createButton(section, buttonText, callback)
    section:Button(buttonText, callback)
end

function saveConfig()
    print("Saving config...")
    local success, err = pcall(function()
        local configString = jsonEncode(macrov2)
        if not configString then error("Can't convert config into file.") end
        if not writefile then error("Save config is not supported by your executor.") end

        writefile("macrov2-tester/BSS_"..player.Name..".json",configString)
    end)
    if success then
        api.notify("Macro V2 - Config", "Config successfully saved.",3)
    elseif err then
        api.notify("Macro V2 - Config", "Error while saving config: \n"..err:split(":")[3],3)
    end
end

function loadConfig(configName)
    warn("Config name: BSS_",configName,".json")
    local success, err = pcall(function()
        if not readfile or not isfile then error("Load config is not supported by your executor.") end
        if not isfile("macrov2-tester/BSS_"..configName..".json") then error("You don't have a saved config.") end

        local oldConfig = macrov2

        local loadedConfig = jsonDecode(readfile("macrov2-tester/BSS_"..configName..".json"))
        if not loadedConfig or typeof(loadedConfig) ~= "table" then error("Config not loaded.") end

        for settingsCategory, settingsTable in pairs(macrov2) do
            if loadedConfig[settingsCategory] then
                for settingName, settingValue in pairs(settingsTable) do
                    if loadedConfig[settingsCategory][settingName] ~= nil then
                        getgenv().macrov2[settingsCategory][settingName] = loadedConfig[settingsCategory][settingName]
                    end
                end
            end
        end

        -- warn(111)

        -- getgenv().macrov2 = loadedConfig

        for settingsType,v in pairs(guiElements) do
            -- warn(settingsType)
            for settingName,k in pairs(v) do
                local tag = k["Tag"]
                -- warn(tag)
                if tag == "Dropdown" then
                    pcall(function()
                        if typeof(macrov2[settingsType][settingName]) == "table" then
                            k:Update(macrov2[settingsType][settingName])
                        else
                            k:Set(macrov2[settingsType][settingName])
                        end
                    end)
                elseif tag == "Slider" then
                    pcall(function()
                        k:Set(tonumber(macrov2[settingsType][settingName]))
                    end)
                elseif tag == "Toggle" then
                    pcall(function()
                        k:Set(macrov2[settingsType][settingName])
                    end)
                elseif tag == "Box" then
                    pcall(function()
                        k:Set(macrov2[settingsType][settingName])
                    end)
                end
            end
        end
    end)

    for cycleName, cycleTable in pairs(customPlanterSections) do
        for cycleStep, stepUIs in pairs(cycleTable) do
            if cycleStep == "section" then continue end

            stepUIs.HarvestAmount:Set(macrov2.customPlanterSettings[cycleName][cycleStep].harvestAmount)
            stepUIs.Field:Set(macrov2.customPlanterSettings[cycleName][cycleStep].field)
            stepUIs.Planter:Set(macrov2.customPlanterSettings[cycleName][cycleStep].planter)
        end
    end

    if success then
        api.notify("Macro V2 - Config", "Config successfully loaded.",3)
    elseif err then
        local errMsg
        if api.isSynV3() then
            errMsg = err:split(":")[1]
        else
            errMsg = err:split(":")[3]
        end
        api.notify("Macro V2 - Config", "Error while loading config: \n"..(errMsg or "no error"),3)
    end
end

if _G.debugging then
    warn("UI init.")
end

--Tabs Init
homeTab = createTab("Home")

informationSection = createSection(homeTab, "Information")
welcomeLabel = createLabel(informationSection, "Welcome, "..--[[ api.nickname]]"Onett".."!")
createButton(informationSection, "Redeem Codes", function() 
    for _,code in pairs(temptable.codesTable) do
        Events.ClientCall("PromoCodeEvent", code)
        wait(0.5)
    end
end)
createToggle(informationSection, "Stop Everything", nil, function(state) 
    temptable.stopEverything = state
end)

statsTrackerSection = createSection(homeTab, "Stats Tracker")
bossTimersSection = createSection(homeTab, "Boss Timers")

uptimeLabel = createLabel(statsTrackerSection, "Uptime: 00:00:00?")
honeyPerHourLabel = createLabel(statsTrackerSection, "Honey Per Hour: 0?")
gainedHoneyLabel = createLabel(statsTrackerSection, "Gained Honey: 0?")
dailyHoneyLabel = createLabel(statsTrackerSection, "Daily Honey: 0?")
balloonPollenLabel = createLabel(statsTrackerSection, "Balloon Pollen: 0?")

kingBeetleTimerLabel = createLabel(bossTimersSection, "King Beetle: 0?")
tunnelBearTimerLabel = createLabel(bossTimersSection, "Tunnel Bear: 0?")
coconutCrabTimerLabel = createLabel(bossTimersSection, "Coconut Crab: 0?")
stumpSnailTimerLabel = createLabel(bossTimersSection, "Stump Snail: 0?")


farmingTab = createTab("Farming")

farmingSection = createSection(farmingTab, "Farming")

createDropdown(farmingSection, "Field", fieldsTable, {"vars", "field"}, true):Set(macrov2.vars.field)

createToggle(farmingSection, "Autofarm [‚öô]", "autofarm", true)
createToggle(farmingSection, "Auto Dig", "autodig", true)
createToggle(farmingSection, "Ignore Honey Tokens", {"autoFarmSettings", "ignoreHoneyTokens"}, true)
createToggle(farmingSection, "Farm Bubbles", "farmBubbles", true)
createToggle(farmingSection, "Farm Shower", {"autoFarmSettings", "farmShower"}, true)
createToggle(farmingSection, "Farm Sprouts", {"autoFarmSettings", "farmSprouts"}, true)
createToggle(farmingSection, "Farm Under Balloons", {"autoFarmSettings", "farmUnderBalloons"}, true)
createToggle(farmingSection, "Smart Bubble Bloat"..Star, {"autoFarmSettings", "smartBubbleBloat"}, true)
createToggle(farmingSection, "Smart Precise Crosshair"..Star, {"autoFarmSettings", "smartPreciseCrosshair"}, true)
createDropdown(farmingSection, "Smart Crosshair farm", {"Fast Tween", "Walk"}, {"autoFarmSettings", "smartPreciseMethod"}, true):Set(macrov2.autoFarmSettings.smartPreciseMethod)
createToggle(farmingSection, "Farm Precise Croshairs", {"autoFarmSettings", "farmPrecise"}, true)
createToggle(farmingSection, "Farm Fuzzy Bombs", {"autoFarmSettings", "farmPrecise"}, true)

automatisationFarmSection = createSection(farmingTab, "Automatisation")

createToggle(automatisationFarmSection, "Auto Dispensers", "autodispensers", true)
createToggle(automatisationFarmSection, "Auto Boosters", "autoboosters", true)
createToggle(automatisationFarmSection, "Auto Memory Match", "automemorymatch", true)

for i,v in pairs(AllToysTable.toysTable) do
    createToggle(automatisationFarmSection, "Auto "..v, {"toggles", i}, true)
end

combatTab = createTab("Combat")

autoBossesSection = createSection(combatTab, "Auto Bosses")
createToggle(autoBossesSection, "Auto kill Crab", {"combatSettings", "trainCrab"}, true)
createToggle(autoBossesSection, "Auto kill King Beetle", {"combatSettings", "trainKingBeetle"}, true)
createToggle(autoBossesSection, "Auto kill Tunnel Bear", {"combatSettings", "trainTunnelBear"}, true)

autoViciousSection = createSection(combatTab, "Auto Vicious")
createToggle(autoViciousSection, "Auto Vicious", {"combatSettings", "killVicious"}, true)
createSlider(autoViciousSection, "Minimum Level", {Min = 1, Max = 12, Default = 1}, {"combatSettings", "viciousMinLevel"}, true)
createSlider(autoViciousSection, "Maximum Level", {Min = 1, Max = 12, Default = 12}, {"combatSettings", "viciousMaxLevel"}, true)

autoQuestTab = createTab("Auto Quest")

questsToDoSection = createSection(autoQuestTab, "Quests to do")
createToggle(questsToDoSection, "Auto Quests", {"autoQuestSettings", "doQuests"}, true)
createToggle(questsToDoSection, "Auto Repeatable Quests", {"autoQuestSettings", "doRepeatables"}, true):Set(true)
createToggle(questsToDoSection, "Accept All Quests", {"autoQuestSettings", "acceptAllQuests"}, true)
createLabel(questsToDoSection, "")
createToggle(questsToDoSection, "Black Bear Quests", {"autoQuestSettings", "BlackBearQuests"}, true)
createToggle(questsToDoSection, "Brown Bear Quests", {"autoQuestSettings", "BrownBearQuests"}, true)
createToggle(questsToDoSection, "Panda Bear Quests", {"autoQuestSettings", "PandaBearQuests"}, true)
createToggle(questsToDoSection, "Science Bear Quests", {"autoQuestSettings", "ScienceBearQuests"}, true)
createToggle(questsToDoSection, "Polar Bear Quests", {"autoQuestSettings", "PolarBearQuests"}, true)
createToggle(questsToDoSection, "Spirit Bear Quests", {"autoQuestSettings", "SpiritsBearQuests"}, true)
createToggle(questsToDoSection, "Bucko Bee Quests", {"autoQuestSettings", "BuckoBeeQuests"}, true)
createToggle(questsToDoSection, "Riley Bee Quests", {"autoQuestSettings", "RileyBeeQuests"}, true)
createToggle(questsToDoSection, "Honey Bee Quests", {"autoQuestSettings", "HoneyBeeQuests"}, true)
createToggle(questsToDoSection, "Onett Quests", {"autoQuestSettings", "OnettQuests"}, true)
if scriptType == "Paid" then
    createToggle(questsToDoSection, "Bee Bear Quests "..Star, {"autoQuestSettings", "BeeBearQuests"}, true)
end

questSettingsSection = createSection(autoQuestTab, "Quests Settings")
createToggle(questSettingsSection, "Teleport to npc", {"autoQuestSettings", "tpToNPC"}, true)
createToggle(questSettingsSection, "Teleport ants", {"autoQuestSettings", "doAnts"}, true)
createToggle(questSettingsSection, "Do Pollen Quests", {"autoQuestSettings", "farmPollen"}, true)
createToggle(questSettingsSection, "Do Goo Quests", {"autoQuestSettings", "farmGoo"}, true)
createToggle(questSettingsSection, "Kill Mobs For Quests", {"autoQuestSettings", "killMobs"}, true)
createToggle(questSettingsSection, "Feed Bees For Quests", {"autoQuestSettings", "feedBees"}, true)
createToggle(questSettingsSection, "Use Toys For Quests", {"autoQuestSettings", "useToys"}, true)
createToggle(questSettingsSection, "Do Memory Match Quests", {"autoQuestSettings", "useMemoryMatch"}, true)
createToggle(questSettingsSection, "Do Quests For Quests", {"autoQuestSettings", "doQuestQuests"}, true)
createDropdown(questSettingsSection, "Blacklisted Nectars List", {})

questFarmSettingsSection = createSection(autoQuestTab, "Quests Farm Settings")
createDropdown(questFarmSettingsSection, "Blue Pollen From", blueFields, {"autoQuestSettings", "bestBlueField"}, true):Set(macrov2.autoQuestSettings.bestBlueField)
createDropdown(questFarmSettingsSection, "Red Pollen From", redFields, {"autoQuestSettings", "bestRedField"}, true):Set(macrov2.autoQuestSettings.bestRedField)
createDropdown(questFarmSettingsSection, "White Pollen From", whiteFields, {"autoQuestSettings", "bestWhiteField"}, true):Set(macrov2.autoQuestSettings.bestWhiteField)

questPrioritySettingsSection = createSection(autoQuestTab, "Quests Priority Settings")
createToggle(questPrioritySettingsSection, "Prioritize Mob Kill Quests", {"autoQuestSettings", "prioritizeMobKill"}, true):Set(true)
createToggle(questPrioritySettingsSection, "Enable NPC Priorities", {"autoQuestSettings", "enablePriorities"}, true)
createDropdown(questPrioritySettingsSection, "Select NPC", npcsTable, false, function(selectedNpc) 
    if temptable.selectedPriorityNpc == selectedNpc then return end
    temptable.selectedPriorityNpc = selectedNpc
    local npcPriority = getQuestSetting(selectedNpc, "prio")
    temptable.npcPrioSlider:Set(tonumber(npcPriority))
end):Set("Polar Bear")

temptable.npcPrioSlider = createSlider(questPrioritySettingsSection, "Select Npc Priority", {Min = 1, Max = 15, Default = 1}, false, function(newPrio)
    if temptable.selectedPriorityNpc == "Bee Bear 5" then
        macrov2.autoQuestSettings.BeeBearPriority = newPrio
    else
        print(temptable.selectedPriorityNpc:gsub(" ","").."Priority")
        macrov2.autoQuestSettings[temptable.selectedPriorityNpc:gsub(" ","").."Priority"] = newPrio
    end
end)


plantersTab = createTab("Planters")

autoPlantersNectarsSection = createSection(plantersTab, "Automatic Planters & Nectars")
createToggle(autoPlantersNectarsSection, "Auto Planters", {"autoPlantersSettings", "doPlanters"}, true)
createToggle(autoPlantersNectarsSection, "Do Custom Planters", {"autoPlantersSettings", "doCustomPlanters"}, true)
-- createToggle(autoPlantersNectarsSection, "Harvest With Puffsrooms", {"autoPlantersSettings", "planterHarvestWithPuffs"}, true):Set(true)

local blacklistedNectarsDropdown
blacklistedNectarsDropdown = autoPlantersNectarsSection:Dropdown("Blacklisted Nectars List", macrov2.autoPlantersSettings.blacklistedNectars, function(selectedOption)
	if selectedOption == nil or selectedOption == "" then return end
    removeFromTable(macrov2.autoPlantersSettings.blacklistedNectars, selectedOption)
	api.notify("Macro V2 | Success", "Unblacklisted "..selectedOption, 2)
	task.spawn(function()
		blacklistedNectarsDropdown:Update(macrov2.autoPlantersSettings.blacklistedNectars)
		wait()
		blacklistedNectarsDropdown:Set("")
	end)
end); guiElements["autoPlantersSettings"]["blacklistedNectars"] = blacklistedNectarsDropdown

createDropdown(autoPlantersNectarsSection, "Blacklist Nectar", nectarsDropdownTable, nil, function(selectedOption) 
    if not table.find(macrov2.autoPlantersSettings.blacklistedNectars, selectedOption) then
        table.insert(macrov2.autoPlantersSettings.blacklistedNectars, selectedOption)
        blacklistedNectarsDropdown:Update(macrov2.autoPlantersSettings.blacklistedNectars)
	    api.notify("Macro V2 | Success", "Blacklisted "..selectedOption, 1)
    end
end)

createSlider(autoPlantersNectarsSection, "Harvest At", {Min = 1, Max = 100, Default = 20} ,{"autoPlantersSettings", "planterHarvestAt"}, true)

local blacklistedPlantersDropdown
blacklistedPlantersDropdown = autoPlantersNectarsSection:Dropdown("Blacklisted Planters List", macrov2.autoPlantersSettings.blacklistedPlanters, function(selectedOption)
	if selectedOption == nil or selectedOption == "" then return end
    removeFromTable(macrov2.autoPlantersSettings.blacklistedPlanters, selectedOption)
	api.notify("Macro V2 | Success", "Unblacklisted "..selectedOption, 2)
	task.spawn(function()
		blacklistedPlantersDropdown:Update(macrov2.autoPlantersSettings.blacklistedPlanters)
		wait()
		blacklistedPlantersDropdown:Set("")
	end)
end); guiElements["autoPlantersSettings"]["blacklistedPlanters"] = blacklistedPlantersDropdown

createDropdown(autoPlantersNectarsSection, "Blacklist Planters", plantersDropdownTable, nil, function(selectedOption) 
    if not table.find(macrov2.autoPlantersSettings.blacklistedPlanters, selectedOption) then
        table.insert(macrov2.autoPlantersSettings.blacklistedPlanters, selectedOption)
        blacklistedPlantersDropdown:Update(macrov2.autoPlantersSettings.blacklistedPlanters)
	    api.notify("Macro V2 | Success", "Blacklisted "..selectedOption, 1)
    end
end)

customPlanterSections = {
    customPlanters1 = {section = createSection(plantersTab, "Custom Planter 1")},
    customPlanters2 = {section = createSection(plantersTab, "Custom Planter 2")},
    customPlanters3 = {section = createSection(plantersTab, "Custom Planter 3")}
}

customFieldDropdown = table.clone(fieldsTable)
customPlanterDropdown = table.clone(plantersDropdownTable)
table.insert(customFieldDropdown, "None")
table.insert(customPlanterDropdown, "None")

for cycleName, cycleTable in pairs(macrov2.customPlanterSettings) do
    if not cycleName:find("customPlanters") then continue end
    for cycleStep, stepTable in pairs(cycleTable) do
        
        if not customPlanterSections[cycleName][cycleStep] then customPlanterSections[cycleName][cycleStep] = {} end

        customPlanterSections[cycleName][cycleStep].Planter = 
            customPlanterSections[cycleName].section:Dropdown("Field "..cycleStep.." Planter", customPlanterDropdown, function(newPlanter) 
                macrov2["customPlanterSettings"][cycleName][cycleStep].planter = newPlanter
                -- stepTable.planter = newPlanter 
            end)

        customPlanterSections[cycleName][cycleStep].Field = 
            customPlanterSections[cycleName].section:Dropdown("Field "..cycleStep, customFieldDropdown, function(newField) 
                macrov2["customPlanterSettings"][cycleName][cycleStep].field = newField
                -- stepTable.field = newField 
            end)

        customPlanterSections[cycleName][cycleStep].HarvestAmount = 
            customPlanterSections[cycleName].section:Slider("Field "..cycleStep.." Harvest %", function(newPercentage) 
                macrov2["customPlanterSettings"][cycleName][cycleStep].harvestAmount = newPercentage 
                -- stepTable.harvestAmount = newPercentage  -- This shit not working, i do not know why (ICrazych)
            end, {Min = 1, Max = 100, Default = 75})

            customPlanterSections[cycleName][cycleStep].Planter:Set("None")
            customPlanterSections[cycleName][cycleStep].Field:Set("None")
            customPlanterSections[cycleName][cycleStep].HarvestAmount:Set(75)
    end
end

writefile("planterSection.json", jsonEncode(customPlanterSections))

warn(111)
for i,v in pairs(customPlanterSections) do
     for i2,v2 in pairs(v) do
        for i3,v3 in pairs(v2) do
            print(i3,v3)
        end
        break
    end
end

if scriptType == "Paid" then
local puffshroomsTab = createTab("Puffshrooms "..Star)

local puffshroomSettingsSection = createSection(puffshroomsTab, "Puffshroom Settings "..Star)
createToggle(puffshroomSettingsSection, "Farm Puffshrooms", {"autoPuffshroomSettings", "farmPuffshrooms"}, true)
createSlider(puffshroomSettingsSection, "Minimum Level", {Min = 1, Max = 15, Default = 1}, {"autoPuffshroomSettings", "minimumLevel"}, true)
createSlider(puffshroomSettingsSection, "Maximum Level", {Min = 1, Max = 30, Default = 16}, {"autoPuffshroomSettings", "maximumLevel"}, true)
createToggle(puffshroomSettingsSection, "Farm Remaining Puffs", {"autoPuffshroomSettings", "farmRemaining"}, true)

local puffshroomPrioSettingsSection = createSection(puffshroomsTab, "Puffshroom Priority Settings "..Star)
createDropdown(puffshroomPrioSettingsSection, "Puffshroom Rarity", {"Mythic > Common", "Common > Mythic"}, {"autoPuffshroomSettings", "rarityPriority"}, true)
createDropdown(puffshroomPrioSettingsSection, "Puffshroom Level", {"High > Low", "Low > High"}, {"autoPuffshroomSettings", "levelPriority"}, true)
end

settingsTab = createTab("Settings")

autoFarmSettingsSection = createSection(settingsTab, "AutoFarm settings")
createSlider(autoFarmSettingsSection, "Convert Honey At", {Min = 0, Max = 100, Default = 100}, {"convertSettings", "convertat"}, true)
createToggle(autoFarmSettingsSection, "Convert Hive Balloon", "converthiveballoon", true)
createSlider(autoFarmSettingsSection, "Convert Balloon At", {Min = 0, Max = 60, Default = 0} , {"convertSettings", "convertballoonat"}, true)
createSlider(autoFarmSettingsSection, "Farm In Field When Full", {Min = 0, Max = 60, Default = 0} , {"convertSettings", "secondsBeforeConvert"}, true)
createToggle(autoFarmSettingsSection, "Convert Honey", "convertHoney", true):Set(true)

localPlayerSettingsSection = createSection(settingsTab, "Local Player Settings")
createSlider(localPlayerSettingsSection, "Walk Speed", {Min = 20, Max = 90, Default = 60} ,"walkspeed", true)
createToggle(localPlayerSettingsSection, "Speedhack", "speedhack", true)
createToggle(localPlayerSettingsSection, "Hide Decorations", nil, function(state) 
    if state then
        temptable.fieldDecosFolder.Parent = ReplicatedStorage
    else
        temptable.fieldDecosFolder.Parent = Workspace
    end
end)

raresSettingsSection = createSection(settingsTab, "Rares Settings")

local raresListDropdown
raresListDropdown = createDropdown(raresSettingsSection, "Rares List (select to remove)", macrov2.raresList, false, function(tokenId) 
	table.remove(macrov2.raresList, table.find(macrov2.raresList, tokenId))
	api.notify("Macro V2 | Success", "Removed "..option.."\nfrom rares list", 2)
	raresListDropdown:Update(macrov2.raresList)
end)

createInput(raresSettingsSection, "Add Rare Id", "numbers only", false, function(tokenId) 
    if not tonumber(tokenId) then return api.notify("Macro V2 - v" .. temptable.version, "Numbers only!", 2) end
    if table.find(macrov2.raresList, tokeId) then return api.notify("Macro V2 - v"..temptable.version, "This rare id is already added!", 2) end

    table.insert(macrov2.raresList, tostring(tokenId))
    raresListDropdown:Update(macrov2.raresList)
    api.notify("Macro V2 - v"..temptable.version, "Successfuly added!", 2)
end)


safetySettingsSection = createSection(settingsTab, "Safety Settings")
createDropdown(safetySettingsSection, "Accessory Equip Method", {"Tween", "Teleport", "Remote"}, {"vars", "equipAccessoryMethod"}, true):Set(macrov2.vars.equipAccessoryMethod)
createDropdown(safetySettingsSection, "Movement Method", {"Tween"}, false, function()end):Set("Tween")


autoDispenserSection = createSection(settingsTab, "Auto Dispensers")
for i,v in pairs(AllToysTable.dispensersTable) do
    createToggle(autoDispenserSection, "Auto "..v, {"autodispensersettings", i}, true)
end

autoBoosterSection = createSection(settingsTab, "Auto Boosters")
for i,v in pairs(AllToysTable.boostersTable) do
    createToggle(autoBoosterSection, "Auto "..v, {"autoboostersettings", i}, true)
end

webhookTab = createTab("Webhook")
webhookSection = createSection(webhookTab, "Webhook")
createToggle(webhookSection, "Use webhook", {"webhookSettings", "useWebhook"}, true)
createSlider(webhookSection, "Message frequency", {Min = 1, Max = 120, Default = 30}, {"webhookSettings", "messageFrequency"}, true)

createInput(webhookSection, "Webhook Url", "ex: https://discord.com/api/...", {"webhookSettings", "webhookUrl"}, true)
createInput(webhookSection, "Discord User Id", "ex: 123456", {"webhookSettings", "discordId"}, true)
createInput(webhookSection, "Webhook Color", "ex: 0xfcdf03 or #fcdf03", {"webhookSettings", "webhookColor"}, function(Color) 
    local done = false
    -- print(Color)
	if string.match(Color, "^".."0x") then 
        -- print(1)
		done = true
		macrov2.webhookSettings.webhookColor = Color
	end
	if not done then
        -- print(2)
		local newColor,_ = string.gsub(Color, "#", "0x") 
		if _ == 1 then
			-- print(newValue)
			macrov2.webhookSettings.webhookColor = newColor
		else
            -- warn("error")
			api.notify("Macro V2 - v" .. temptable.version, "Invalid Color!", 2)
			api.notify("Macro V2 - v" .. temptable.version, "Make sure you're using Hex color.", 5)
		end
	end
end)

createToggle(webhookSection, "Ping discord id", {"webhookSettings", "pingUser"}, true)

createButton(webhookSection, "Test Webhook", function()
    sendHourlyWebhook(true)
end)

webhookSettingsSection = createSection(webhookTab, "Webhook Settings")
createToggle(webhookSettingsSection, "Show Total Honey", {"webhookSettings", "showTotalHoney"}, true)
createToggle(webhookSettingsSection, "Show Honey Per Hour", {"webhookSettings", "showHoneyPerHour"}, true)
createToggle(webhookSettingsSection, "Show Daily Honey", {"webhookSettings", "showDailyHoney"}, true)
createToggle(webhookSettingsSection, "Show Nectars", {"webhookSettings", "showNectars"}, true)
createToggle(webhookSettingsSection, "Show Planters", {"webhookSettings", "showPlanters"}, true)
createToggle(webhookSettingsSection, "Show Items", {"webhookSettings", "showItems"}, true)
createToggle(webhookSettingsSection, "Truncated only", {"webhookSettings", "onlyTruncated"}, true)

configTab = createTab("Config")
defaultConfigSection = createSection(webhookTab, "Default Config")
createButton(defaultConfigSection, "Save Settings", saveConfig)

if scriptType == "Paid" then

premiumTab = createTab("Premium")
-- smartFarmSection = createSection(premiumTab, "Smart Farming")
-- createToggle(smartFarmSection, "Smart Blue Farm (End Game Only)", {"toggles", "smartBlueAutofarm"}, true)
-- createToggle(smartFarmSection, "Smart Red Farm", {"toggles", "smartRedAutofarm"}, true)

beesmasFeaturesSection = createSection(premiumTab, "Beesmas Features")
for i,v in pairs(AllToysTable.beesmasToysTable) do
    createToggle(beesmasFeaturesSection, "Auto "..v, {"toggles", i}, true)
end

paidMiscSection = createSection(premiumTab, "Misc")
createToggle(paidMiscSection, "Alert on Vicious Spawn", {"alertSettings", "viciousAlert"}, true):Set(true)

local autoRJSection = createSection(premiumTab, "Auto Royal Jelly")

local selectedBeesDropdown
local selectedRaritiesDropdown

local RJSettings = temptable.autoRJSettings

autoRJSection:Dropdown("Add Bee", beesTable.namesOnly, function(selectedBee) 
    if not table.find(RJSettings.selectedBees, selectedBee) then
        if RJSettings.requireGifted then selectedBee = "Gifted "..selectedBee end
        table.insert(RJSettings.selectedBees, selectedBee)
        selectedBeesDropdown:Update(RJSettings.selectedBees)
    end
end)

autoRJSection:Dropdown("Add Rarity", beesTable.raritiesTable, function(selectedRarity) 
    if not table.find(RJSettings.selectedRarities, selectedRarity) then
        if RJSettings.requireGifted then selectedRarity = "Gifted "..selectedRarity end
        table.insert(RJSettings.selectedRarities, selectedRarity)
        selectedRaritiesDropdown:Update(RJSettings.selectedRarities)
    end
end)

autoRJSection:Toggle("Require Gifted", function(newState) 
    RJSettings.requireGifted = newState
end)

selectedBeesDropdown = autoRJSection:Dropdown("Selected Bees", RJSettings.selectedBees, function(selectedBee)
    local selectedIndex = table.find(RJSettings.selectedBees, selectedBee)
    RJSettings.selectedBees[selectedIndex] = nil
    selectedBeesDropdown:Update(RJSettings.selectedBees)
end)

selectedRaritiesDropdown = autoRJSection:Dropdown("Selected Rarities", RJSettings.selectedRarities, function(selectedRarity)
    local selectedIndex = table.find(RJSettings.selectedRarities, selectedRarity)
    RJSettings.selectedRarities[selectedIndex] = nil
    selectedRaritiesDropdown:Update(RJSettings.selectedRarities)
end)

autoRJSection:Toggle("Stop on any gifted", function(newState) 
    RJSettings.requireAnyGifted = newState
end)

autoRJSection:Slider("Left > Right", function(newCoordinate) RJSettings.xCoord = newCoordinate end, {Min = 1, Max = 5, Default = 3})
autoRJSection:Slider("Down > Up", function(newCoordinate) RJSettings.yCoord = newCoordinate end, {Min = 1, Max = 10, Default = 1})

createButton(autoRJSection, "Start Auto RJ", startAutoRJ)
createButton(autoRJSection, "Emergency Stop", stopAutoRJ)
-- createButton(autoRJSection, "Check Bee", function() 
--     print(isBeeExpected(plrHive.Cells[("C%s,%s"):format(RJSettings.xCoord, RJSettings.yCoord)]))
-- end)

end

if _G.debugging then
    warn("UI init done. waiting 5 seconds")
    wait(5)
end

if _G.debugging then
    warn("Calling functions")
end

loopFunction.spawn(function()
    if temptable.stopEverything then return wait(0.1) end
    if canTaskBeSpawned("getToys") then
        getToys() -- Starting main function with checking all toys
    end

    if macrov2.autoPlantersSettings.doPlanters and canTaskBeSpawned("farmPlanters") then
        farmPlanters() -- Second step, check all planters
    end

    if macrov2.combatSettings.killVicious and temptable.detected.vicious and canTaskBeSpawned("killVicious") then
        killVicious() -- Third step, kill vicious if found.
    end

    -- auto Bosses below.
    if canTaskBeSpawned("trainBosses") then
        if macrov2.combatSettings.trainKingBeetle then
            trainKingBeetle()
        end

        if macrov2.combatSettings.trainCrab then
            trainCrab()
        end

        if macrov2.combatSettings.trainTunnelBear then
            trainTunnelBear()
        end
    end

    if macrov2.toggles.autofarm then
        if not macrov2.toggles.convertHoney or not shouldIConvert() then

            if temptable.puffsDetected and macrov2.autoPuffshroomSettings.farmPuffshrooms then
                farmPuffshrooms()
                return
            end

            if macrov2.autoFarmSettings.farmSprouts then
                farmSprouts()
            end

            selectField(macrov2.vars.field)
            pcall(function()
                if macrov2.toggles.smartBlueAutofarm then
                    temptable.fieldPosition = getNewFarmCenter(temptable.fieldSelected, true).Position
                end
            end)

            if macrov2.autoQuestSettings.doQuests then
                doQuests()
            end

            if not isFieldSame(api.humanoidrootpart().Position, temptable.fieldPosition) then
                moveTo(temptable.fieldPosition + Vector3.new(0,3,0))
                wait()
                placeSprinklers(temptable.fieldPosition)
            end

            if macrov2.autoFarmSettings.farmShower then
                farmShower()
            end

            local isActive = false
            local canContinueFarm = true

            if macrov2.autoFarmSettings.smartPreciseCrosshair and #getCrosshairs().all > 0 then
                if smartFarmCrosshairs() then return end 
            end

            if macrov2.autoFarmSettings.smartBubbleBloat and temptable.popStarActive and getBuffTime("Pop Star Aura") < 7200 then
                local isBubbleFarmed = false
                canContinueFarm = false
                temptable.customWalkSpeed.enabled = true
                temptable.customWalkSpeed.speed = 65
                for i=1,3 do
                    if farmBubble(function(bubble) 
                        if findField(bubble.Position) == temptable.fieldSelected then return true end
                    end) and math.random(1,2) == 1 then isBubbleFarmed = true end
                end
                if not isBubbleFarmed then canContinueFarm = true end
                temptable.customWalkSpeed.enabled = false
            end

            local importantFarmTaskCallback = function(token)
                if findField(token.Position) == temptable.fieldSelected then return true end
            end

            if canContinueFarm then
                for i=1,3 do
                    if macrov2.autoFarmSettings.farmShower and #temptable.showersTable > 0 then return end
                    local nearestName = getNearestTask()
                    if nearestName == "Bubble" then
                        local isFarmed = farmBubble(importantFarmTaskCallback)
                        isActive = isActive or isFarmed or false
                    else
                        local isFarmed = farmToken(importantFarmTaskCallback)
                        isActive = isActive or isFarmed or false
                    end
                end
            end
            -- warn(isActive)
            if not isActive then
                if macrov2.autoFarmSettings.farmUnderBalloons then
                    gotoNearestBalloon()
                end
                wait()
            else
                if macrov2.autoFarmSettings.farmUnderBalloons then
                    local number = getBagPercentage()/10
                    if number > 7 then number = 7 elseif number < 3 then number = 3 end
                    local randomNumber = math.random(1, 10)
                    -- warn(number, randomNumber)
                    if randomNumber <= number then
                        gotoNearestBalloon(true)
                    end
                end
            end

             if not macrov2.toggles.smartBlueAutofarm and not isTokenFarmed and (tick() - temptable.lastWalkToNearest > 3) then
                local randomFlower = getRandomFlower(temptable.fieldSelected)
               if randomFlower then
                    temptable.lastWalkToNearest = tick()
                     api.humanoid():MoveTo(randomFlower.Position)
                 end
             elseif macrov2.toggles.smartBlueAutofarm then
                 if math.random(1,10) == 10 then
                     local newPos = getNewFarmCenter(temptable.fieldSelected).Position
                    if newPos then
                     api.humanoid():MoveTo(newPos)
                     end
                 end
                 wait()
             end
        elseif macrov2.toggles.convertHoney and shouldIConvert() then
            convertHoney(macrov2.toggles.converthiveballoon)
        end
        
    end
    
end, true, 0, "Autofarm")

loopFunction.spawn(function() 
    if macrov2.toggles.autodig then
        local a,b = pcall(function() dig() end)
        if not a then error(b) end
    end
end, true, 0.03, "Auto dig")

loopFunction.spawn(function()
    if temptable.customWalkSpeed.enabled then
        api.humanoid().WalkSpeed = temptable.customWalkSpeed.speed
    else
        if macrov2.toggles.speedhack then
            local newSpeed = macrov2.vars.walkspeed
            pcall(function()
                local systemSpeed = getClientStatCache("ModifierCaches","Value","PlayerMovespeed", "_")
                if tonumber(systemSpeed) and systemSpeed > newSpeed then newSpeed = systemSpeed end
            end)
            player.Character.Humanoid.WalkSpeed = newSpeed
        end
    end
end, true, 0.03, "Local Player Settings")

loopFunction.spawn(function()
    if macrov2.webhookSettings.useWebhook then
        if tick() - temptable.lastWebhookSent > macrov2.webhookSettings.messageFrequency * 60 then
            sendHourlyWebhook()
        end
    end
end, true, 10, "Webhooking")

loopFunction.spawn(function()
    local currentHoney = getClientStatCache("Totals","Honey")
	local timePassed = math.round(tick() - currentMacroV2LoadedAt)
	local honeyGained = currentHoney - temptable.honeyAtStart
    local honeyPerHour = math.floor(honeyGained / timePassed) * 3600
    local dailyHoney = getDailyHoney()
    local balloonPolen = temptable.lastBalloonPollen
    if tick() - temptable.lastClientStatCacheUpdate > 5 then
        local temp = updateClientStatCache("HiveBalloon")
        balloonPolen = temp and temp["Pollen"] or 0
        temptable.lastBalloonPollen = balloonPolen
        temptable.lastClientStatCacheUpdate = tick()
    end

	local honeyGainedString = truncate(honeyGained)
	local honeyPerHourString = truncate(honeyPerHour)
	local honeyPerDayString = truncate(dailyHoney)
    local uptimeString = truncatetime(timePassed)
	local honeyPerDayString = truncate(dailyHoney)
	local balloonPolenString = truncate(balloonPolen)

    uptimeLabel:Set("Uptime: "..uptimeString)
    honeyPerHourLabel:Set("Honey Per Hour: "..honeyPerHourString)
    gainedHoneyLabel:Set("Gained Honey: "..honeyGainedString)
    dailyHoneyLabel:Set("Daily Honey: "..honeyPerDayString)
    balloonPollenLabel:Set("Balloon Pollen: "..balloonPolenString)

    kingBeetleTimerLabel:Set("King Beetle: "..getCooldownBySpawner("King Beetle Cave"))
    tunnelBearTimerLabel:Set("Tunnel Bear: "..getCooldownBySpawner("TunnelBear"))
    coconutCrabTimerLabel:Set("Coconut Crab: "..getCooldownBySpawner("CoconutCrab"))
    stumpSnailTimerLabel:Set("Stump Snail: "..getCooldownBySpawner("StumpSnail"))
end, true, 1, "Stats Tracker")

loopFunction.spawn(function()
    checkPuffshrooms()
    checkPopStar()
    -- checkLeafsAndSparkles()
end, true, 0.5, "Important Listener")


for i, v in pairs(Workspace.Particles:GetChildren()) do
    if v.Name:find("Vicious") then
        temptable.detected.vicious = true
    end
end

for i,instance in pairs(Workspace.Particles.Folder2:GetChildren()) do
    if instance.Name == "Sprout" then
        local sproutRarity = sproutRarities[instance.Color]
        local sproutField = findField(instance.Position)
        --[[print(sproutRarity)]]
        local sproutId = math.round(tick()*10)/10
        local temp = Instance.new("StringValue",instance)
        temp.Name = "SproutId"
        temp.Value = sproutId
        if sproutRarity ~= "Moon" then
            temptable.sproutsTable[sproutId] = {Model = instance, Field = sproutField}
        end
    end
end

-- for i,v in pairs(temptable.tokenpath:GetChildren()) do
--     table.insert(temptable.tokensTable, v)
-- end

-- Listening
local addedListener1 = Workspace.Particles.ChildAdded:Connect(function(instance)
    wait()
	if string.find(instance.Name, "Vicious") then
		temptable.detected.vicious = true

    elseif instance.Name == "Guiding Star" then 
        print("guiding added handler")

    elseif instance.Name == "WarningDisk" and instance.BrickColor == BrickColor.new("Lime green") then
        if instance.Size.X == 8 and true then
            if tick() - temptable.lastShowerRegistered < 0.05 then return end
            table.insert(temptable.showersTable, instance)
            temptable.lastShowerRegistered = tick()
        end

	end
end)

local removedListener1 = Workspace.Particles.ChildRemoved:Connect(function(instance)
	if string.find(instance.Name, "Vicious") then
		temptable.detected.vicious = false

    elseif instance.Name == "Guiding Star" then
        print("guiding removed handler")

    elseif instance.Name == "WarningDisk" and instance.BrickColor == BrickColor.new("Lime green") then
        if instance.Size.X == 8 and true then
            local index = table.find(temptable.showersTable, instance)
            if index then table.remove(temptable.showersTable, index) end
        end

	end
end)

local addedListener2 = Workspace.Particles.Folder2.ChildAdded:Connect(function(instance)
    wait()
    if instance.Name ~= "Sprout" then return end
	local sproutRarity = sproutRarities[instance.Color]
    local sproutField = findField(instance.Position)
    print("Spawned sprout rarity:", sproutRarity)
    local sproutId = math.round(tick()*10)/10
    local temp = Instance.new("StringValue",instance)
    temp.Name = "SproutId"
    temp.Value = sproutId
    if sproutRarity ~= "Moon" then
        temptable.sproutsTable[sproutId] = {Model = instance, Field = sproutField}
    end
end)

local removedListener2 = Workspace.Particles.Folder2.ChildRemoved:Connect(function(instance)
    wait()
    if instance.Name ~= "Sprout" then return end
	local sproutId = instance:FindFirstChild("SproutId")
    if sproutId then
        temptable.sproutsTable[sproutId.Value] = nil
    else
        warn("no sprout id :skull:")
    end
end)

local addedListener3 = Workspace.Monsters.ChildAdded:Connect(function(monster)
    wait()
    if monster.Name:find("Vicious") then
        local viciousOnField = findField(monster.HumanoidRootPart.Position)
        bssAlert("Vicious", monster.Name.." spawned on "..viciousOnField.Name)
    end
end)

local leafSparkleAddedListener = Flowers.DescendantAdded:Connect(function(instance)
    wait()
    if instance.Name == "LeafBurst" then
        table.insert(temptable.leafTable, instance)
    elseif instance.Name == "Sparkles" then
        table.insert(temptable.sparklesTable, instance)
    end
end)

local leafSparkleRemovedListener = Flowers.DescendantRemoving:Connect(function(instance)
    wait()
    if instance.Name == "LeafBurst" then
        local index = table.find(temptable.leafTable, instance)
        if index then
            table.remove(temptable.leafTable, index)
        end
    elseif instance.Name == "Sparkles" then
        local index = table.find(temptable.sparklesTable, instance)
        if index then
            table.remove(temptable.sparklesTable, index)
        end
    end
end)

local tokenAddedListener = temptable.tokenpath.ChildAdded:Connect(function(token)
    wait()
    if token.Name == "C" then
        table.insert(temptable.tokensTable, token)
    end
end)

local tokenRemovedListener = temptable.tokenpath.ChildRemoved:Connect(function(token)
    local tokenIndex = table.find(temptable.tokensTable, token)
    if tokenIndex then
        table.remove(temptable.tokensTable, tokenIndex)
    end
end)

local balloonAddedListener
local balloonRemovedListener
spawn(function() 
    repeat wait(1) until Workspace:FindFirstChild("Balloons") and Workspace.Balloons:FindFirstChild("FieldBalloons")
    balloonAddedListener = Workspace.Balloons.FieldBalloons.ChildAdded:Connect(function(balloon) 
        wait()
        if balloon:FindFirstChild("PlayerName") and balloon.PlayerName.Value == player.Name then
            local balloonId = balloon.Name:gsub("Balloon", "")
            temptable.balloonsTable[tonumber(balloonId)] = balloon
        end
    end)
    balloonRemovedListener = Workspace.Balloons.FieldBalloons.ChildRemoved:Connect(function(balloon)
        if balloon:FindFirstChild("PlayerName") and balloon.PlayerName.Value == player.Name then
            local balloonId = balloon.Name:gsub("Balloon", "")
            if balloonId then
                temptable.balloonsTable[tonumber(balloonId)] = nil
            end
        end
    end)
end)

player.Idled:Connect(function()
	VirtualUser:Button2Down(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
	task.wait(1)
	VirtualUser:Button2Up(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
end)

if _G.debugging then
    warn("Calling functions done. WaiTINg 5 Seconds")
    wait(5)
end

if _G.debugging then
    warn("Loading config")
end

warn(player.Name)

loadConfig(player.Name)
if _G.debugging then
    warn("Loading config donee. Waiting..")
    wait(5)
end



-- Remove/Hide decorations
spawn(function() 
    for _, v in pairs(Workspace.Decorations.Misc:GetDescendants()) do
        if v.Parent.Name == "Mushroom" then
            v.CanCollide = false
            v.Transparency = 0.3
        end
    end
    for _,v in pairs(Workspace.MonsterBarriers:GetChildren()) do
        v.CanCollide = false
    end
    for _,v in pairs(Workspace.Paths:GetChildren()) do
        v.CanCollide = false
    end
    for _, v in pairs(temptable.fieldDecosFolder:GetDescendants()) do
        if v:IsA("BasePart") then
            v.CanCollide = false
            v.Transparency = 0.3
        end
    end
    for _, v in pairs(Workspace.Decorations:GetDescendants()) do
        if v:IsA("BasePart") and
            (v.Parent.Name == "Bush" or v.Parent.Name == "Blue Flower") then
            v.CanCollide = false
            v.Transparency = 0.3
        end
    end
    Workspace.Gates["15 Bee Gate"].Frame.CanCollide = false
end)



local killMV2 = Instance.new("BindableEvent")

killMV2.Event:connect(function() 
    print("Killing Macro V2")
    loopFunction.stopAll()
    addedListener1:Disconnect()
    removedListener1:Disconnect()

    addedListener2:Disconnect()

    addedListener3:Disconnect()

    tokenAddedListener:Disconnect()
    tokenRemovedListener:Disconnect()

    balloonAddedListener:Disconnect()
    balloonRemovedListener:Disconnect()
end)

LPH_NO_VIRTUALIZE(function() 
    while wait(1) do
        if currentMacroV2LoadedAt ~= macroV2LoadedAt then
            killMV2:Fire()
            return
        end
    end
end)()
